This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
_docs/
  braindumpIMG2VID.md
  braindumpTXT2IMG.md
  repomix.md
.cursor/
  rules/
    create-feature-prd.mdc
    debug-commands.mdc
    generate-tasks.mdc
    mobile-first-web.mdc
    npm-package-check.mdc
    process-task-list.mdc
    react-native-expo.mdc
    terminal-path-verification.mdc
    yoda-quotes.mdc
app/
  (tabs)/
    _layout.tsx
    camera.tsx
    explore.tsx
    index.tsx
  _layout.tsx
  +not-found.tsx
components/
  ui/
    IconSymbol.ios.tsx
    IconSymbol.tsx
    TabBarBackground.ios.tsx
    TabBarBackground.tsx
  Collapsible.tsx
  ExternalLink.tsx
  HapticTab.tsx
  HelloWave.tsx
  ParallaxScrollView.tsx
  ThemedText.tsx
  ThemedView.tsx
constants/
  Colors.ts
hooks/
  useColorScheme.ts
  useColorScheme.web.ts
  useThemeColor.ts
lib/
  auth.ts
  photoService.ts
  supabase.ts
scripts/
  reset-project.js
store/
  authStore.ts
supabase/
  migrations/
    20250101000001_auth_tables.sql
  .gitignore
  config.toml
tasks/
  prd-veo-creative-image-messenger.md
  tasks-prd-veo-creative-image-messenger.md
.env.example
.gitignore
app.json
eslint.config.js
package.json
README.md
tsconfig.json

================================================================
Files
================================================================

================
File: _docs/braindumpIMG2VID.md
================
# VEO Creative Video Messenger
## Product Requirements Document

### Product Overview

Creative Video Messenger is an ephemeral video messaging platform that transforms photos into AI-generated videos using creative prompts. Users capture images, select AI prompts, and send transformed videos to friends through group messaging. Only the AI-generated video result is shared, creating surprising and entertaining conversations that automatically delete after 24 hours.

### Target Audience

Social media users who want to connect with friends through creative, AI-enhanced video content and enjoy spontaneous, humorous digital interactions.

---

## Core User Stories

1. **Authentication**: As a user, I want to authenticate with Supabase so I can access my groups and video history
2. **Group Creation**: As a user, I want to select from pre-populated fake users to create a 3-4 person group so I can share videos with multiple friends
3. **Image Capture**: As a user, I want to capture a photo with my phone camera so I can create an image to transform into video content
4. **Automatic Deletion**: As a user, I want my transformed videos to automatically delete after 24 hours so conversations stay ephemeral and spontaneous
5. **Image-to-Video Transformation**: As a user, I want to add an AI prompt to my image and send it to my group so friends receive a surprising AI-generated video
6. **Prompt Selection**: As a user, I want to choose from categorized prompt suggestions or create custom prompts so I can easily transform my videos in creative ways

---

## Technical Requirements

### Technology Stack
- **Frontend**: React Native with Expo for cross-platform mobile development
- **Backend**: Supabase (PostgreSQL, Edge Functions, Authentication, Storage, Realtime)
- **AI Processing**: Replicate API with minimax/video-01 model (free tier) for image-to-video generation
- **Styling**: NativeWind/Tailwind CSS for responsive design
- **State Management**: Zustand for app state management

### Core Features

#### Authentication & User Management
- Supabase authentication integration
- Pre-populated fake user system for testing and demonstration
- Simple user profiles with usernames and avatars

#### Group Management
- Create groups by selecting 3-4 fake users from pre-populated list
- Simple group messaging interface
- Group member management

#### Image Capture & Video Generation
- Photo capture using device camera
- Categorized AI prompt suggestion system:
  - **Mood-based**: "Make it epic", "Turn it spooky", "Make it vintage"
  - **Style-based**: "Pixar animation", "Comic book", "Oil painting"
  - **Action-based**: "Add explosions", "Slow motion drama", "Make it dance"
- Custom prompt text input
- Replicate API integration with minimax/video-01 for image-to-video transformation
- Real-time processing status updates via Supabase Realtime
- Processing completion required before sending

#### Messaging & Sharing
- Group video sharing (transformed videos only)
- 24-hour automatic content deletion
- Processing status indicators
- Basic video viewing interface

### Database Schema

```sql
-- Pre-populated fake users
users (id, username, avatar_url, created_at)

-- Group management
groups (id, name, created_by, created_at)
group_members (group_id, user_id, joined_at)

-- Prompt templates
prompt_templates (id, category, title, prompt, popularity)

-- Image messages with video generation status
image_messages (
  id, user_id, group_id, 
  original_image_url, selected_prompt, generated_video_url,
  status, created_at, expires_at
)
```

### Processing Flow

1. User captures photo with device camera
2. User selects AI prompt from categories or creates custom prompt
3. Image uploaded to Supabase Storage
4. Image-to-video generation request sent to Replicate API (minimax/video-01) via Supabase Edge Function
5. Real-time status updates provided to user during processing (20-60 seconds)
6. Completed AI-generated video sent to group members
7. Original image and generated video automatically deleted after 24 hours

---

## Design Requirements

### User Experience
- **Playful, humorous UI personality** that matches the creative, entertaining nature of the app
- **Seamless image capture workflow** from photo taking to prompt selection to sending
- **Clear processing state indicators** to manage user expectations during AI transformation
- **Mobile-first responsive design** optimized for smartphone usage
- **Simple group creation interface** for easy fake user selection

### Key Screens
1. **Authentication Screen**: Simple login/signup via Supabase
2. **Group Selection/Creation**: Browse and create groups with fake users
3. **Image Capture**: Photo taking with camera controls
4. **Prompt Selection**: Categorized suggestions + custom input
5. **Processing Status**: Real-time progress indicator for video generation
6. **Group Chat**: View received AI-generated videos
7. **Settings**: Basic user preferences

---

## Technical Considerations

### Performance Requirements
- Image-to-video generation: 20-60 seconds typical (handled by Replicate minimax/video-01)
- Image upload/video download: Sub-3 second response times
- Real-time updates: Immediate status notifications via Supabase Realtime
- Storage: Automatic cleanup of expired content

### Cost Estimation
- Replicate API: FREE with minimax/video-01 model
- Supabase: Generous free tier for prototype/testing
- Storage: Minimal due to 24-hour ephemeral nature

### Scalability Notes
- Template app approach with fake users eliminates user acquisition complexity
- Supabase handles infrastructure scaling automatically
- Replicate API manages AI model scaling and availability

---

## Success Metrics

### Core Functionality
- All 6 user stories fully functional
- Successful image-to-video generation rate >95%
- Processing completion within 60 seconds
- Zero data persistence beyond 24-hour limit

### User Experience
- Seamless image capture flow without interruption
- Intuitive prompt selection with <10 second decision time
- Clear processing status communication
- Engaging AI-generated video results

---


### Technical Debt Management
- Abstract video generation to easily swap AI providers
- Modular prompt system for easy category expansion
- Clean separation between fake user system and future real user implementation

================
File: _docs/braindumpTXT2IMG.md
================
# VEO Creative Image Messenger
## Product Requirements Document

### Product Overview

VEO Creative Image Messenger is an ephemeral messaging platform that transforms text prompts into AI-generated images using Google's Imagen-4. Users create text prompts and send AI-generated images to friends through group messaging. Only the AI-generated image result is shared, creating surprising and entertaining conversations that automatically delete after 24 hours.

### Target Audience

Social media users who want to connect with friends through creative, AI-enhanced video content and enjoy spontaneous, humorous digital interactions.

---

## Core User Stories

1. **Authentication**: As a user, I want to authenticate with Supabase so I can access my groups and video history
2. **Group Creation**: As a user, I want to select from pre-populated fake users to create a 3-4 person group so I can share videos with multiple friends
3. **Text Prompt Creation**: As a user, I want to create text prompts so I can generate AI images to share
4. **Automatic Deletion**: As a user, I want my generated images to automatically delete after 24 hours so conversations stay ephemeral and spontaneous
5. **Text-to-Image Generation**: As a user, I want to send my text prompt to my group so friends receive a surprising AI-generated image
6. **Prompt Selection**: As a user, I want to choose from categorized prompt suggestions or create custom prompts so I can easily generate creative images

---

## Technical Requirements

### Technology Stack
- **Frontend**: React Native with Expo for cross-platform mobile development
- **Backend**: Supabase (PostgreSQL, Edge Functions, Authentication, Storage, Realtime)
- **AI Processing**: Replicate API with google/imagen-4 model for text-to-image generation
- **Styling**: NativeWind/Tailwind CSS for responsive design
- **State Management**: Zustand for app state management

### Core Features

#### Authentication & User Management
- Supabase authentication integration
- Pre-populated fake user system for testing and demonstration
- Simple user profiles with usernames and avatars

#### Group Management
- Create groups by selecting 3-4 fake users from pre-populated list
- Simple group messaging interface
- Group member management

#### Text-to-Image Generation
- Text prompt input interface with character limits
- Categorized AI prompt suggestion system:
  - **Style-based**: "photorealistic", "cartoon style", "oil painting", "anime"
  - **Mood-based**: "epic fantasy", "cozy atmosphere", "dramatic lighting"
  - **Subject-based**: "cute animals", "space scenes", "food photography"
- Custom prompt text input with helpful tips
- Replicate API integration with google/imagen-4 for text-to-image generation
- Real-time processing status updates via Supabase Realtime
- Processing completion required before sending

#### Messaging & Sharing
- Group video sharing (transformed videos only)
- 24-hour automatic content deletion
- Processing status indicators
- Basic video viewing interface

### Database Schema

```sql
-- Pre-populated fake users
users (id, username, avatar_url, created_at)

-- Group management
groups (id, name, created_by, created_at)
group_members (group_id, user_id, joined_at)

-- Prompt templates
prompt_templates (id, category, title, prompt, popularity)

-- Text prompt messages with image generation status
text_messages (
  id, user_id, group_id, 
  text_prompt, generated_image_url,
  status, created_at, expires_at
)
```

### Processing Flow

1. User creates text prompt using input interface or selects from suggestions
2. User selects or customizes prompt categories and styles
3. Text prompt processed by Replicate API (google/imagen-4) via Supabase Edge Function
4. Real-time status updates provided to user during processing (5-15 seconds)
5. Completed AI-generated image sent to group members
6. Generated images automatically deleted after 24 hours

---

## Design Requirements

### User Experience
- **Playful, humorous UI personality** that matches the creative, entertaining nature of the app
- **Seamless prompt creation workflow** from text input to generation to sending
- **Clear processing state indicators** to manage user expectations during AI transformation
- **Mobile-first responsive design** optimized for smartphone usage
- **Simple group creation interface** for easy fake user selection

### Key Screens
1. **Authentication Screen**: Simple login/signup via Supabase
2. **Group Selection/Creation**: Browse and create groups with fake users
3. **Text Prompt Input**: Text creation interface with suggestions
4. **Style Selection**: Categorized style and mood options
5. **Processing Status**: Real-time progress indicator for image generation
6. **Group Chat**: View received AI-generated images
7. **Settings**: Basic user preferences

---

## Technical Considerations

### Performance Requirements
- Text-to-image generation: 5-15 seconds typical (handled by Replicate google/imagen-4)
- Image download: Sub-3 second response times
- Real-time updates: Immediate status notifications via Supabase Realtime
- Storage: Automatic cleanup of expired content

### Cost Estimation
- Replicate API: ~$0.01-0.05 per image generation (very affordable)
- Supabase: Generous free tier for prototype/testing
- Storage: Minimal due to 24-hour ephemeral nature

### Scalability Notes
- Template app approach with fake users eliminates user acquisition complexity
- Supabase handles infrastructure scaling automatically
- Replicate API manages AI model scaling and availability

---

## Success Metrics

### Core Functionality
- All 6 user stories fully functional
- Successful text-to-image generation rate >95%
- Processing completion within 15 seconds
- Zero data persistence beyond 24-hour limit

### User Experience
- Seamless prompt creation flow without interruption
- Intuitive style selection with <10 second decision time
- Clear processing status communication
- High-quality AI-generated image results

---

## Future Considerations

================
File: _docs/repomix.md
================
npx repomix > codebase.txt

================
File: .cursor/rules/create-feature-prd.mdc
================
---
description: Guide for generating a detailed Product Requirements Document (PRD) based on user prompts
globs: **/tasks/**/*.md, **/prd-*.md
---

# Rule: Generating a Product Requirements Document (PRD)

// Description: Guide for generating a detailed Product Requirements Document (PRD) based on user prompts
// Recommended Globs: **/tasks/**/*.md, **/prd-*.md

## Goal

To guide an AI assistant in creating a detailed Product Requirements Document (PRD) in Markdown format, based on an initial user prompt. The PRD should be clear, actionable, and suitable for a junior developer to understand and implement the feature.

## Process

1.  **Receive Initial Prompt:** The user provides a brief description or request for a new feature or functionality.
2.  **Ask Clarifying Questions:** Before writing the PRD, the AI *must* ask clarifying questions to gather sufficient detail. The goal is to understand the "what" and "why" of the feature, not necessarily the "how" (which the developer will figure out).
3.  **Generate PRD:** Based on the initial prompt and the user's answers to the clarifying questions, generate a PRD using the structure outlined below.
4.  **Save PRD:** Save the generated document as `prd-[feature-name].md` inside the `/tasks` directory.

## Clarifying Questions (Examples)

The AI should adapt its questions based on the prompt, but here are some common areas to explore:

*   **Problem/Goal:** "What problem does this feature solve for the user?" or "What is the main goal we want to achieve with this feature?"
*   **Target User:** "Who is the primary user of this feature?"
*   **Core Functionality:** "Can you describe the key actions a user should be able to perform with this feature?"
*   **User Stories:** "Could you provide a few user stories? (e.g., As a [type of user], I want to [perform an action] so that [benefit].)"
*   **Acceptance Criteria:** "How will we know when this feature is successfully implemented? What are the key success criteria?"
*   **Scope/Boundaries:** "Are there any specific things this feature *should not* do (non-goals)?"
*   **Data Requirements:** "What kind of data does this feature need to display or manipulate?"
*   **Design/UI:** "Are there any existing design mockups or UI guidelines to follow?" or "Can you describe the desired look and feel?"
*   **Edge Cases:** "Are there any potential edge cases or error conditions we should consider?"

## PRD Structure

The generated PRD should include the following sections:

1.  **Introduction/Overview:** Briefly describe the feature and the problem it solves. State the goal.
2.  **Goals:** List the specific, measurable objectives for this feature.
3.  **User Stories:** Detail the user narratives describing feature usage and benefits.
4.  **Functional Requirements:** List the specific functionalities the feature must have. Use clear, concise language (e.g., "The system must allow users to upload a profile picture."). Number these requirements.
5.  **Non-Goals (Out of Scope):** Clearly state what this feature will *not* include to manage scope.
6.  **Design Considerations (Optional):** Link to mockups, describe UI/UX requirements, or mention relevant components/styles if applicable.
7.  **Technical Considerations (Optional):** Mention any known technical constraints, dependencies, or suggestions (e.g., "Should integrate with the existing Auth module").
8.  **Success Metrics:** How will the success of this feature be measured? (e.g., "Increase user engagement by 10%", "Reduce support tickets related to X").
9.  **Open Questions:** List any remaining questions or areas needing further clarification.

## Target Audience

Assume the primary reader of the PRD is a **junior developer**. Therefore, requirements should be explicit, unambiguous, and avoid jargon where possible. Provide enough detail for them to understand the feature's purpose and core logic.

## Output

*   **Format:** Markdown (`.md`)
*   **Location:** `/tasks/`
*   **Filename:** `prd-[feature-name].md`

## Final instructions

1. Do NOT start implementing the PRD
2. Make sure to ask the user clarifying questions
3. Take the user's answers to the clarifying questions and improve the PRD

================
File: .cursor/rules/debug-commands.mdc
================
---
description: This tool performs debugging steps for applications
globs: **/*.{js,ts,jsx,tsx,py,html,css,json}
---

# Debug Commands

// Description: This tool performs debugging steps for applications
// Recommended Globs: **/*.{js,ts,jsx,tsx,py,html,css,json}

## Overview
Debug commands provide a streamlined approach to troubleshooting applications by gathering console logs, network errors, and taking screenshots to help identify and fix issues.

## Core Commands

### `/debug` Command
When you type `/debug` in the chat, the AI will automatically:
1. Gather all console logs from the browser
2. Collect any console errors
3. Take a screenshot of the current application state

## Implementation

```javascript
// Example implementation of debug command handler
async function handleDebugCommand() {
  // Gather console logs
  const consoleLogs = await mcp__getConsoleLogs();
  
  // Collect console errors
  const consoleErrors = await mcp__getConsoleErrors();
  
  // Take screenshot
  const screenshot = await mcp__takeScreenshot();
  
  // Analyze and present results
  return {
    consoleLogs,
    consoleErrors,
    screenshot
  };
}
```

## Usage Examples

### Example 1: Debugging a React Application
```
User: My React app is showing a blank screen
AI: Let me help you debug this issue. Type /debug to gather diagnostic information.
User: /debug
AI: [Executes debug command and analyzes results]
    I've found the following issues:
    1. Console error: "TypeError: Cannot read property 'map' of undefined"
    The screenshot shows a blank page with React's error boundary not properly configured.
```

### Example 2: Troubleshooting API Integration
```
User: My API calls are failing and I'm not sure why
AI: Let's investigate. Type /debug while the application is making the API call.
User: /debug
AI: [Executes debug command and analyzes results]
    I've found the following issues:
    1. Console log shows the authorization header is missing
    Based on the screenshot, you need to add proper authentication to your API calls.
```

## Best Practices

### When to Use Debug Commands
- When an application shows unexpected behavior
- When there are no visible error messages
- When troubleshooting network or API issues
- When investigating performance problems
- When helping users who can't easily access developer tools

### Interpreting Debug Results
- Look for patterns in console errors
- Check for failed network requests
- Examine the visual state in screenshots
- Correlate timestamps between different logs
- Identify missing resources or dependencies

### Security Considerations
- Ensure sensitive information is not captured in logs or screenshots
- Be cautious with debugging production environments
- Consider implementing log sanitization for sensitive data
- Use secure channels when sharing debug information

## Supported Environments
- Web browsers (Chrome, Firefox, Safari, Edge)
- React, Angular, Vue applications
- Node.js backend services
- Python applications with proper logging
- Mobile web applications

## Additional Commands

### `/debug:console`
Focus specifically on console output:
```
User: /debug:console
AI: [Gathers console logs and errors]
```

### `/debug:visual`
Focus specifically on visual issues:
```
User: /debug:visual
AI: [Takes screenshot and analyzes visual elements]
```

## Resources
- [Browser DevTools Documentation](https://developer.chrome.com/docs/devtools/)
- [React Error Boundaries](https://reactjs.org/docs/error-boundaries.html)
- [JavaScript Debugging Techniques](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Debugging)
- [Python Debugging Tools](https://docs.python.org/3/library/debug.html)

================
File: .cursor/rules/generate-tasks.mdc
================
---
description: Guide for creating detailed task lists from Product Requirements Documents (PRDs)
globs: **/tasks/**/*.md, **/tasks-*.md
---

# Rule: Generating a Task List from a PRD

// Description: Guide for creating detailed task lists from Product Requirements Documents (PRDs)
// Recommended Globs: **/tasks/**/*.md, **/tasks-*.md

## Goal

To guide an AI assistant in creating a detailed, step-by-step task list in Markdown format based on an existing Product Requirements Document (PRD). The task list should guide a developer through implementation.

## Output

- **Format:** Markdown (`.md`)
- **Location:** `/tasks/`
- **Filename:** `tasks-[prd-file-name].md` (e.g., `tasks-prd-user-profile-editing.md`)

## Process

1.  **Receive PRD Reference:** The user points the AI to a specific PRD file
2.  **Analyze PRD:** The AI reads and analyzes the functional requirements, user stories, and other sections of the specified PRD.
3.  **Phase 1: Generate Parent Tasks:** Based on the PRD analysis, create the file and generate the main, high-level tasks required to implement the feature. Use your judgement on how many high-level tasks to use. It's likely to be about 5. Present these tasks to the user in the specified format (without sub-tasks yet). Inform the user: "I have generated the high-level tasks based on the PRD. Ready to generate the sub-tasks? Respond with 'Go' to proceed."
4.  **Wait for Confirmation:** Pause and wait for the user to respond with "Go".
5.  **Phase 2: Generate Sub-Tasks:** Once the user confirms, break down each parent task into smaller, actionable sub-tasks necessary to complete the parent task. Ensure sub-tasks logically follow from the parent task and cover the implementation details implied by the PRD.
6.  **Identify Relevant Files:** Based on the tasks and PRD, identify potential files that will need to be created or modified. List these under the `Relevant Files` section, including corresponding test files if applicable.
7.  **Generate Final Output:** Combine the parent tasks, sub-tasks, relevant files, and notes into the final Markdown structure.
8.  **Save Task List:** Save the generated document in the `/tasks/` directory with the filename `tasks-[prd-file-name].md`, where `[prd-file-name]` matches the base name of the input PRD file (e.g., if the input was `prd-user-profile-editing.md`, the output is `tasks-prd-user-profile-editing.md`).

## Output Format

The generated task list _must_ follow this structure:

```markdown
## Relevant Files

- `path/to/potential/file1.ts` - Brief description of why this file is relevant (e.g., Contains the main component for this feature).
- `path/to/file1.test.ts` - Unit tests for `file1.ts`.
- `path/to/another/file.tsx` - Brief description (e.g., API route handler for data submission).
- `path/to/another/file.test.tsx` - Unit tests for `another/file.tsx`.
- `lib/utils/helpers.ts` - Brief description (e.g., Utility functions needed for calculations).
- `lib/utils/helpers.test.ts` - Unit tests for `helpers.ts`.

### Notes

- Unit tests should typically be placed alongside the code files they are testing (e.g., `MyComponent.tsx` and `MyComponent.test.tsx` in the same directory).
- Use `npx jest [optional/path/to/test/file]` to run tests. Running without a path executes all tests found by the Jest configuration.

## Tasks

- [ ] 1.0 Parent Task Title
  - [ ] 1.1 [Sub-task description 1.1]
  - [ ] 1.2 [Sub-task description 1.2]
- [ ] 2.0 Parent Task Title
  - [ ] 2.1 [Sub-task description 2.1]
- [ ] 3.0 Parent Task Title (may not require sub-tasks if purely structural or configuration)
```

## Interaction Model

The process explicitly requires a pause after generating parent tasks to get user confirmation ("Go") before proceeding to generate the detailed sub-tasks. This ensures the high-level plan aligns with user expectations before diving into details.

## Target Audience

Assume the primary reader of the task list is a **junior developer** who will implement the feature.

================
File: .cursor/rules/mobile-first-web.mdc
================
---
description: Best practices for mobile-first web development using Tailwind, React, and Firebase
globs: **/*.{js,jsx,ts,tsx}, **/tailwind.config.{js,ts}, **/firebase.config.{js,ts}
---

# Mobile First Web Development

// Description: Best practices for mobile-first web development using Tailwind, React, and Firebase
// Recommended Globs: **/*.{js,jsx,ts,tsx}, **/tailwind.config.{js,ts}, **/firebase.config.{js,ts}

## Project Structure
```
src/
  components/
    common/
      Button.tsx
      Card.tsx
      Modal.tsx
    features/
      medications/
        MedicationCard.tsx
        MedicationList.tsx
        AdherenceReport.tsx
    layout/
      Header.tsx
      Navigation.tsx
  hooks/
    useMedications.ts
    useAuth.ts
    useFirestore.ts
  pages/
    dashboard/
    medications/
    reports/
  services/
    firebase/
    analytics/
  styles/
    tailwind.css
  utils/
    dates.ts
    statistics.ts
```

## Design System Configuration
```javascript
// tailwind.config.js
module.exports = {
  content: ['./src/**/*.{js,jsx,ts,tsx}'],
  theme: {
    extend: {
      colors: {
        primary: {
          50: '#f0f9ff',
          100: '#e0f2fe',
          // ... other shades
          900: '#0c4a6e'
        },
        // ... other color scales
      },
      spacing: {
        'safe-top': 'env(safe-area-inset-top)',
        'safe-bottom': 'env(safe-area-inset-bottom)'
      },
      fontSize: {
        'fluid-sm': 'clamp(0.875rem, 0.8rem + 0.25vw, 1rem)',
        'fluid-base': 'clamp(1rem, 0.925rem + 0.375vw, 1.125rem)',
        'fluid-lg': 'clamp(1.125rem, 1.05rem + 0.5vw, 1.25rem)'
      }
    }
  },
  plugins: [
    require('@tailwindcss/forms'),
    require('@tailwindcss/aspect-ratio')
  ]
}
```

## Responsive Components
```typescript
// src/components/features/medications/MedicationCard.tsx
import { useState } from 'react';
import { motion } from 'framer-motion';

interface MedicationCardProps {
  medication: Medication;
  onTake: () => void;
  onSkip: () => void;
}

export function MedicationCard({ medication, onTake, onSkip }: MedicationCardProps) {
  const [showConfirm, setShowConfirm] = useState(false);

  return (
    <motion.div
      layout
      className="p-4 bg-white rounded-lg shadow-md
                 sm:p-6 md:p-8
                 hover:shadow-lg transition-shadow
                 touch-manipulation"
      whileTap={{ scale: 0.98 }}
    >
      <div className="flex items-center space-x-4">
        <div className="flex-shrink-0">
          <img
            src={medication.imageUrl}
            alt={medication.name}
            className="w-16 h-16 rounded-full
                       sm:w-20 sm:h-20
                       object-cover"
          />
        </div>
        <div className="flex-1 min-w-0">
          <h3 className="text-fluid-lg font-semibold text-gray-900
                         truncate">
            {medication.name}
          </h3>
          <p className="text-fluid-sm text-gray-500">
            {medication.dosage} • {medication.schedule}
          </p>
        </div>
      </div>

      <div className="mt-4 flex space-x-3
                      sm:mt-6">
        <button
          onClick={() => setShowConfirm(true)}
          className="flex-1 min-h-[44px] px-4 py-2
                     bg-primary-600 text-white
                     rounded-lg font-medium
                     hover:bg-primary-700
                     focus:outline-none focus:ring-2
                     focus:ring-primary-500 focus:ring-offset-2
                     transition-colors"
          aria-label={`Take ${medication.name}`}
        >
          Take
        </button>
        <button
          onClick={() => setShowConfirm(true)}
          className="flex-1 min-h-[44px] px-4 py-2
                     border border-gray-300
                     text-gray-700
                     rounded-lg font-medium
                     hover:bg-gray-50
                     focus:outline-none focus:ring-2
                     focus:ring-primary-500 focus:ring-offset-2
                     transition-colors"
          aria-label={`Skip ${medication.name}`}
        >
          Skip
        </button>
      </div>

      {showConfirm && (
        <ConfirmationModal
          medication={medication}
          onConfirm={onTake}
          onCancel={() => setShowConfirm(false)}
        />
      )}
    </motion.div>
  );
}
```

## Firebase Integration
- Use Node.js 20 for Cloud Functions (MANDATORY as v18 is being deprecated)
- Follow modular SDK approach

```typescript
// functions/package.json
{
  "name": "functions",
  "engines": {
    "node": "20"
  },
  "dependencies": {
    "firebase-admin": "^12.0.0",
    "firebase-functions": "^4.5.0"
  }
}

// src/services/firebase/medications.ts
import { collection, query, where, orderBy, getDocs } from 'firebase/firestore';

export async function getMedicationsBySchedule(userId: string, schedule: string) {
  try {
    const q = query(
      collection(db, 'medications'),
      where('userId', '==', userId),
      where('schedule', '==', schedule),
      orderBy('name')
    );

    const querySnapshot = await getDocs(q);
    return querySnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));
  } catch (error) {
    console.error('Error fetching medications:', error);
    throw error;
  }
}

export async function logMedicationAction(
  userId: string,
  medicationId: string,
  action: 'take' | 'skip',
  notes?: string
) {
  try {
    await addDoc(collection(db, 'medication_logs'), {
      userId,
      medicationId,
      action,
      notes,
      timestamp: serverTimestamp()
    });
  } catch (error) {
    console.error('Error logging medication action:', error);
    throw error;
  }
}
```

## Custom Hooks
```typescript
// src/hooks/useMedications.ts
import { useState, useEffect } from 'react';
import { useFirestore } from './useFirestore';
import { useAuth } from './useAuth';

export function useMedications(schedule: string) {
  const [medications, setMedications] = useState<Medication[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  const { user } = useAuth();
  const { getMedicationsBySchedule } = useFirestore();

  useEffect(() => {
    if (!user) return;

    async function fetchMedications() {
      try {
        const data = await getMedicationsBySchedule(user.id, schedule);
        setMedications(data);
      } catch (err) {
        setError(err as Error);
      } finally {
        setLoading(false);
      }
    }

    fetchMedications();
  }, [user, schedule]);

  return { medications, loading, error };
}
```

## Best Practices

### Mobile-First Design
- Start with mobile layout and progressively enhance for larger screens
- Use Tailwind's responsive prefixes (sm:, md:, lg:, xl:) consistently
- Ensure touch targets are at least 44x44 pixels
- Implement proper safe area insets for modern mobile devices

### Performance
- Implement code splitting with React.lazy() and Suspense
- Use proper image optimization techniques
- Implement virtualization for long lists
- Enable Firebase offline persistence

### Accessibility
- Maintain WCAG 2.1 compliance
- Use semantic HTML elements
- Implement proper ARIA attributes
- Ensure proper color contrast ratios

### Firebase Security
- Implement proper security rules
- Use batch operations for related updates
- Implement proper error handling
- Enable offline persistence

### Animation Guidelines
- Use subtle animations for feedback
- Implement proper loading states
- Consider reduced motion preferences
- Use consistent transition timing

### Form Handling
- Implement proper validation
- Show clear error messages
- Use proper input types
- Implement proper keyboard handling

## Resources
- [Tailwind CSS Documentation](https://tailwindcss.com/docs)
- [React Documentation](https://reactjs.org/docs)
- [Firebase Documentation](https://firebase.google.com/docs)
- [WCAG Guidelines](https://www.w3.org/WAI/standards-guidelines/wcag/)

================
File: .cursor/rules/npm-package-check.mdc
================
---
description: Best practices for checking and installing NPM packages before use
globs: **/*.{js,jsx,ts,tsx}, **/package.json
---

# NPM Package Check

// Description: Best practices for checking and installing NPM packages before use
// Recommended Globs: **/*.{js,jsx,ts,tsx}, **/package.json

## Overview
Ensure all required NPM packages are properly installed before use to prevent runtime errors.

## Package Check Process
1. Before requiring any npm package, check package.json dependencies
2. If package exists in dependencies:
   - Output: "✓ {package_name} is already installed"
3. If package NOT found:
   - Output terminal command: `npm install {package_name}`

## Example Implementation
```javascript
const fs = require('fs');
const path = require('path');

function checkPackage(packageName) {
  try {
    const packageJson = JSON.parse(
      fs.readFileSync(path.join(process.cwd(), 'package.json'), 'utf8')
    );

    const deps = {
      ...packageJson.dependencies,
      ...packageJson.devDependencies
    };

    if (deps[packageName]) {
      console.log(`✓ ${packageName} is already installed`);
      return true;
    } else {
      console.log(`Installing ${packageName}...`);
      console.log(`Run: npm install ${packageName}`);
      return false;
    }
  } catch (error) {
    console.error('Error reading package.json:', error);
    return false;
  }
}
```

## Usage Example
```javascript
// Before importing a package
if (checkPackage('express')) {
  const express = require('express');
  // Use express...
} else {
  console.error('Please install express first');
  process.exit(1);
}
```

## Best Practices
- Always check packages before requiring them
- Handle missing package.json gracefully
- Consider both dependencies and devDependencies
- Provide clear installation instructions
- Exit gracefully if required packages are missing

## Common Patterns
- Pre-startup dependency check
- Dynamic package loading
- Development tooling setup
- Build process validation

================
File: .cursor/rules/process-task-list.mdc
================
---
description: Guidelines for managing task lists in markdown files to track progress on completing a PRD
globs: **/tasks/**/*.md, **/tasks-*.md
---

# Task List Management

// Description: Guidelines for managing task lists in markdown files to track progress on completing a PRD
// Recommended Globs: **/tasks/**/*.md, **/tasks-*.md

Guidelines for managing task lists in markdown files to track progress on completing a PRD

## Task Implementation
- **One sub-task at a time:** Do **NOT** start the next sub‑task until you ask the user for permission and they say "yes" or "y"
- **Completion protocol:**
  1. When you finish a **sub‑task**, immediately mark it as completed by changing `[ ]` to `[x]`.
  2. If **all** subtasks underneath a parent task are now `[x]`, also mark the **parent task** as completed.
- Stop after each sub‑task and wait for the user's go‑ahead.

## Task List Maintenance

1. **Update the task list as you work:**
   - Mark tasks and subtasks as completed (`[x]`) per the protocol above.
   - Add new tasks as they emerge.

2. **Maintain the "Relevant Files" section:**
   - List every file created or modified.
   - Give each file a one‑line description of its purpose.

## AI Instructions

When working with task lists, the AI must:

1. Regularly update the task list file after finishing any significant work.
2. Follow the completion protocol:
   - Mark each finished **sub‑task** `[x]`.
   - Mark the **parent task** `[x]` once **all** its subtasks are `[x]`.
3. Add newly discovered tasks.
4. Keep "Relevant Files" accurate and up to date.
5. Before starting work, check which sub‑task is next.
6. After implementing a sub‑task, update the file and then pause for user approval.

================
File: .cursor/rules/react-native-expo.mdc
================
---
description: Best practices for React Native development using Expo SDK and TypeScript
globs: **/*.{ts,tsx}, **/app.json, **/app.config.{js,ts}, **/assets/**/*
---

# React Native Expo

// Description: Best practices for React Native development using Expo SDK and TypeScript
// Recommended Globs: **/*.{ts,tsx}, **/app.json, **/app.config.{js,ts}, **/assets/**/*

## Project Structure
```
project_name/
├── assets/
│   ├── fonts/
│   └── images/
├── src/
│   ├── components/
│   │   ├── common/
│   │   └── screens/
│   ├── screens/
│   │   ├── auth/
│   │   └── main/
│   ├── navigation/
│   │   ├── types.ts
│   │   └── AppNavigator.tsx
│   ├── hooks/
│   │   ├── useAuth.ts
│   │   └── useTheme.ts
│   └── utils/
│       ├── api.ts
│       └── storage.ts
├── App.tsx
├── app.json
├── app.config.ts
└── tsconfig.json
```

## Component Structure
```typescript
import { StyleSheet } from 'react-native';
import { useTheme } from '@hooks/useTheme';

interface CardProps {
  title: string;
  description?: string;
  onPress?: () => void;
}

export const Card: React.FC<CardProps> = ({
  title,
  description,
  onPress
}) => {
  const { colors } = useTheme();

  return (
    <Pressable
      style={[styles.container, { backgroundColor: colors.card }]}
      onPress={onPress}
    >
      <Text style={[styles.title, { color: colors.text }]}>
        {title}
      </Text>
      {description && (
        <Text style={[styles.description, { color: colors.text }]}>
          {description}
        </Text>
      )}
    </Pressable>
  );
};

const styles = StyleSheet.create({
  container: {
    padding: 16,
    borderRadius: 8,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
  },
  title: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  description: {
    marginTop: 8,
    fontSize: 14,
  },
});
```

## Navigation Setup
```typescript
// src/navigation/types.ts
export type RootStackParamList = {
  Home: undefined;
  Profile: { userId: string };
  Settings: undefined;
};

// src/navigation/AppNavigator.tsx
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';

const Stack = createNativeStackNavigator<RootStackParamList>();

export const AppNavigator = () => {
  return (
    <NavigationContainer>
      <Stack.Navigator>
        <Stack.Screen name="Home" component={HomeScreen} />
        <Stack.Screen name="Profile" component={ProfileScreen} />
        <Stack.Screen name="Settings" component={SettingsScreen} />
      </Stack.Navigator>
    </NavigationContainer>
  );
};
```

## Custom Hooks
```typescript
// src/hooks/useAuth.ts
import { useSecureStore } from './useSecureStore';

interface AuthState {
  token: string | null;
  user: User | null;
}

export const useAuth = () => {
  const [state, setState] = useState<AuthState>({
    token: null,
    user: null,
  });

  const { getItem, setItem } = useSecureStore();

  const login = async (credentials: Credentials) => {
    try {
      const response = await api.auth.login(credentials);
      await setItem('token', response.token);
      setState({ token: response.token, user: response.user });
    } catch (error) {
      throw new Error('Login failed');
    }
  };

  return { ...state, login };
};
```

## Asset Management
```typescript
// app.config.ts
import { ExpoConfig } from '@expo/config';

const config: ExpoConfig = {
  name: 'MyApp',
  version: '1.0.0',
  extra: {
    apiUrl: process.env.API_URL,
  },
  splash: {
    image: './assets/splash.png',
    resizeMode: 'contain',
    backgroundColor: '#ffffff',
  },
  updates: {
    fallbackToCacheTimeout: 0,
    url: 'https://u.expo.dev/your-project-id',
  },
  assetBundlePatterns: [
    'assets/images/*',
    'assets/fonts/*',
  ],
};

export default config;
```

## Error Handling
```typescript
// src/utils/error-boundary.tsx
import * as Sentry from 'sentry-expo';

interface ErrorBoundaryProps {
  children: React.ReactNode;
  fallback: React.ReactNode;
}

export class ErrorBoundary extends React.Component<
  ErrorBoundaryProps,
  { hasError: boolean }
> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError() {
    return { hasError: true };
  }

  componentDidCatch(error: Error, info: React.ErrorInfo) {
    Sentry.Native.captureException(error);
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback;
    }

    return this.props.children;
  }
}
```

## Push Notifications
```typescript
// src/utils/notifications.ts
import * as Notifications from 'expo-notifications';

export const registerForPushNotifications = async () => {
  const { status } = await Notifications.requestPermissionsAsync();
  if (status !== 'granted') {
    return;
  }

  const token = await Notifications.getExpoPushTokenAsync({
    projectId: 'your-project-id',
  });

  return token;
};

export const configurePushNotifications = () => {
  Notifications.setNotificationHandler({
    handleNotification: async () => ({
      shouldShowAlert: true,
      shouldPlaySound: true,
      shouldSetBadge: true,
    }),
  });
};
```

## Best Practices

### Component Design
- Use functional components with hooks
- Keep components small and focused
- Implement proper prop types with TypeScript
- Use memo for performance optimization

### State Management
- Use Context for global state
- Implement proper data fetching patterns
- Handle loading and error states
- Use proper form state management

### Performance
- Implement proper list rendering
- Use proper image optimization
- Implement proper memory management
- Handle offline support

### Security
- Use Expo's secure store for sensitive data
- Implement proper authentication flow
- Handle proper data encryption
- Implement proper session management

## Resources
- [Expo Documentation](https://docs.expo.dev)
- [React Navigation](https://reactnavigation.org)
- [Expo Vector Icons](https://icons.expo.fyi)
- [Sentry Expo](https://docs.expo.dev/guides/using-sentry)

================
File: .cursor/rules/terminal-path-verification.mdc
================
---
description: Best practices for verifying paths and locations before executing terminal commands
globs: **/*.{js,jsx,ts,tsx}, **/*.sh
---

# Terminal Path Verification

// Description: Best practices for verifying paths and locations before executing terminal commands
// Recommended Globs: **/*.{js,jsx,ts,tsx}, **/*.sh

## Overview
Always verify current directory and path structure before executing path-related commands to prevent errors and unintended operations.

## Core Rules
1. Before any `cd` command:
   - Use `pwd` to verify current location
   - Use `ls` to verify target directory exists
2. Before file operations:
   - Use `ls` to verify file existence
   - Use `ls -la` for detailed file information when needed

## Examples

### ✅ Good Practice
```bash
# Before changing directory
pwd  # Check current location
ls   # Verify directory structure
cd target_directory

# Before file operations
ls -la file_to_modify.txt  # Verify file exists and check permissions
vim file_to_modify.txt
```

### ❌ Bad Practice
```bash
# Directly changing directory without verification
cd some_directory  # Might not exist!

# File operations without verification
rm file.txt  # Dangerous without verification!
```

## Implementation in Cursor
```typescript
async function executeTerminalCommand(command: string) {
  // Always verify location before path-related commands
  if (command.startsWith('cd ')) {
    await verifyPath(command.split(' ')[1]);
  }

  // Always verify file existence before file operations
  if (isFileOperation(command)) {
    await verifyFileExistence(command);
  }
}

async function verifyPath(targetPath: string) {
  // Check current location
  console.log('Current location:');
  await runCommand('pwd');

  // List directory contents
  console.log('\nDirectory contents:');
  await runCommand('ls');

  // Verify target exists
  if (!(await pathExists(targetPath))) {
    throw new Error(`Target path does not exist: ${targetPath}`);
  }
}
```

## Best Practices
- Always use `pwd` before changing directories
- Use `ls` to verify directory contents
- Use `ls -la` when file permissions are important
- Implement path verification in automated scripts
- Add error handling for non-existent paths

## Common Patterns
1. Directory Navigation:
   ```bash
   pwd  # Verify current location
   ls   # Check directory structure
   cd ./project/src
   ```

2. File Operations:
   ```bash
   ls -la target_file.txt  # Verify file and permissions
   chmod +x target_file.txt
   ```

3. Project Root Verification:
   ```bash
   pwd  # Ensure we're in project root
   ls package.json  # Verify project file exists
   npm install
   ```

## Error Prevention
- Always verify paths before destructive operations
- Use absolute paths when location is uncertain
- Implement safeguards in automated scripts
- Add validation for user-provided paths

## Testing
- Test path verification in different environments
- Verify behavior with non-existent paths
- Test with various file permissions
- Validate error handling

## Resources
- [Bash Documentation](https://www.gnu.org/software/bash/manual/)
- [Linux File System Hierarchy](https://refspecs.linuxfoundation.org/FHS_3.0/fhs/index.html)
- [File System Navigation Best Practices](https://tldp.org/LDP/abs/html/)

================
File: .cursor/rules/yoda-quotes.mdc
================
---
description: End each Cursor chat with a wise, Yoda-style inspirational quote
globs: **/*.{md,txt}
---

# Yoda-Style Quote Endings

// Description: End each Cursor chat with a wise, Yoda-style inspirational quote
// Recommended Globs: **/*.{md,txt}

## Rule Description
At the end of every Cursor AI chat, include a wise and inspirational quote in Yoda's style.

## Format
- Add a line break after the last technical response
- Start with '---'
- Add '➡️ ' before the quote
- Add the quote in Yoda's distinctive speech pattern
- Keep it short and meaningful

## Examples
```
---
➡️ Code well you must, for in the details, greatness lies.
```

```
---
➡️ Debug or debug not. There is no try-catch.
```

## Guidelines
- Keep quotes programming or learning related
- Maintain Yoda's distinctive inverted speech pattern
- Focus on wisdom and encouragement
- Keep it light and fun
- Always include the '➡️ ' emoji prefix

## Purpose
- Add personality to coding sessions
- Provide encouragement during challenging tasks
- Make debugging more enjoyable
- Test rule installation functionality

================
File: lib/auth.ts
================
/**
 * Authentication Utilities
 * 
 * This module provides utility functions for authentication management including:
 * - Session validation and management
 * - User profile operations
 * - Email validation
 * - Password strength validation
 */

import type { UserProfile } from '../store/authStore';
import { supabase } from './supabase';

/**
 * Email validation regex pattern
 * Matches standard email format: user@domain.com
 */
const EMAIL_REGEX = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

/**
 * Password validation requirements
 * - Minimum 8 characters
 * - At least 1 uppercase letter
 * - At least 1 lowercase letter
 * - At least 1 number
 */
const PASSWORD_REGEX = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d@$!%*?&]{8,}$/;

/**
 * Validate email format
 */
export function validateEmail(email: string): boolean {
  console.log('📧 Auth Utils - Validating email format');
  return EMAIL_REGEX.test(email.trim());
}

/**
 * Validate password strength
 */
export function validatePassword(password: string): {
  isValid: boolean;
  errors: string[];
} {
  console.log('🔒 Auth Utils - Validating password strength');
  const errors: string[] = [];

  if (password.length < 8) {
    errors.push('Password must be at least 8 characters long');
  }

  if (!/[a-z]/.test(password)) {
    errors.push('Password must contain at least one lowercase letter');
  }

  if (!/[A-Z]/.test(password)) {
    errors.push('Password must contain at least one uppercase letter');
  }

  if (!/\d/.test(password)) {
    errors.push('Password must contain at least one number');
  }

  return {
    isValid: errors.length === 0,
    errors,
  };
}

/**
 * Validate username format
 * - 3-20 characters
 * - Alphanumeric and underscores only
 * - Cannot start or end with underscore
 */
export function validateUsername(username: string): {
  isValid: boolean;
  error?: string;
} {
  console.log('👤 Auth Utils - Validating username format');
  
  if (!username || username.length < 3) {
    return { isValid: false, error: 'Username must be at least 3 characters long' };
  }

  if (username.length > 20) {
    return { isValid: false, error: 'Username must be no more than 20 characters long' };
  }

  if (!/^[a-zA-Z0-9_]+$/.test(username)) {
    return { isValid: false, error: 'Username can only contain letters, numbers, and underscores' };
  }

  if (username.startsWith('_') || username.endsWith('_')) {
    return { isValid: false, error: 'Username cannot start or end with an underscore' };
  }

  return { isValid: true };
}

/**
 * Check if username is available
 */
export async function checkUsernameAvailability(username: string): Promise<{
  isAvailable: boolean;
  error?: string;
}> {
  console.log('🔍 Auth Utils - Checking username availability:', username);

  try {
    const { data, error } = await supabase
      .from('users')
      .select('username')
      .eq('username', username.toLowerCase())
      .maybeSingle();

    if (error) {
      console.error('❌ Auth Utils - Username check error:', error);
      return { isAvailable: false, error: 'Failed to check username availability' };
    }

    const isAvailable = !data;
    console.log('✅ Auth Utils - Username availability:', isAvailable ? 'Available' : 'Taken');
    
    return { isAvailable };
  } catch (error) {
    console.error('❌ Auth Utils - Username check unexpected error:', error);
    return { isAvailable: false, error: 'Failed to check username availability' };
  }
}

/**
 * Get current user session
 */
export async function getCurrentSession() {
  console.log('📱 Auth Utils - Getting current session');
  
  try {
    const { data: { session }, error } = await supabase.auth.getSession();
    
    if (error) {
      console.error('❌ Auth Utils - Session fetch error:', error);
      return { session: null, error: error.message };
    }

    console.log('✅ Auth Utils - Session retrieved:', session ? 'Found' : 'None');
    return { session, error: null };
  } catch (error) {
    console.error('❌ Auth Utils - Session fetch unexpected error:', error);
    return { 
      session: null, 
      error: error instanceof Error ? error.message : 'Failed to get session' 
    };
  }
}

/**
 * Get user profile by ID
 */
export async function getUserProfile(userId: string): Promise<{
  profile: UserProfile | null;
  error?: string;
}> {
  console.log('👤 Auth Utils - Getting user profile:', userId);

  try {
    const { data, error } = await supabase
      .from('users')
      .select('*')
      .eq('id', userId)
      .single();

    if (error) {
      console.error('❌ Auth Utils - Profile fetch error:', error);
      return { profile: null, error: error.message };
    }

    console.log('✅ Auth Utils - Profile retrieved successfully');
    return { profile: data };
  } catch (error) {
    console.error('❌ Auth Utils - Profile fetch unexpected error:', error);
    return { 
      profile: null, 
      error: error instanceof Error ? error.message : 'Failed to get profile' 
    };
  }
}

/**
 * Update user profile
 */
export async function updateUserProfile(
  userId: string, 
  updates: Partial<Pick<UserProfile, 'username' | 'avatar_url'>>
): Promise<{
  profile: UserProfile | null;
  error?: string;
}> {
  console.log('📝 Auth Utils - Updating user profile:', userId, updates);

  try {
    const { data, error } = await supabase
      .from('users')
      .update(updates)
      .eq('id', userId)
      .select()
      .single();

    if (error) {
      console.error('❌ Auth Utils - Profile update error:', error);
      return { profile: null, error: error.message };
    }

    console.log('✅ Auth Utils - Profile updated successfully');
    return { profile: data };
  } catch (error) {
    console.error('❌ Auth Utils - Profile update unexpected error:', error);
    return { 
      profile: null, 
      error: error instanceof Error ? error.message : 'Failed to update profile' 
    };
  }
}

/**
 * Check if user is authenticated
 */
export async function isAuthenticated(): Promise<boolean> {
  const { session } = await getCurrentSession();
  return !!session?.user;
}

/**
 * Get user ID from current session
 */
export async function getCurrentUserId(): Promise<string | null> {
  const { session } = await getCurrentSession();
  return session?.user?.id || null;
}

/**
 * Format authentication error messages for user display
 */
export function formatAuthError(error: string): string {
  console.log('⚠️ Auth Utils - Formatting auth error:', error);

  // Common Supabase auth error mappings
  const errorMappings: Record<string, string> = {
    'Invalid login credentials': 'Invalid email or password. Please check your credentials and try again.',
    'User not found': 'No account found with this email address. Please sign up first.',
    'Email not confirmed': 'Please check your email and click the confirmation link before signing in.',
    'Signup not allowed': 'Account registration is currently disabled. Please contact support.',
    'Password should be at least 6 characters': 'Password must be at least 6 characters long.',
    'User already registered': 'An account with this email already exists. Please sign in instead.',
    'Invalid email': 'Please enter a valid email address.',
    'Too many requests': 'Too many login attempts. Please wait a moment and try again.',
  };

  return errorMappings[error] || error;
}

/**
 * Generate a secure random password
 */
export function generateSecurePassword(length: number = 12): string {
  const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@$!%*?&';
  let password = '';
  
  // Ensure at least one character from each required category
  password += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'[Math.floor(Math.random() * 26)]; // Uppercase
  password += 'abcdefghijklmnopqrstuvwxyz'[Math.floor(Math.random() * 26)]; // Lowercase
  password += '0123456789'[Math.floor(Math.random() * 10)]; // Number
  password += '@$!%*?&'[Math.floor(Math.random() * 7)]; // Special character
  
  // Fill remaining length with random characters
  for (let i = 4; i < length; i++) {
    password += charset[Math.floor(Math.random() * charset.length)];
  }
  
  // Shuffle the password to randomize character positions
  return password.split('').sort(() => Math.random() - 0.5).join('');
}

================
File: store/authStore.ts
================
/**
 * Authentication Store using Zustand
 * 
 * This store manages global authentication state including:
 * - User session management
 * - Login/logout functionality
 * - Registration handling
 * - Session persistence and restoration
 */

import type { Session, User } from '@supabase/supabase-js';
import { create } from 'zustand';
import { supabase } from '../lib/supabase';

// User profile interface matching our database schema
export interface UserProfile {
  id: string;
  email: string;
  username?: string;
  avatar_url?: string;
  created_at: string;
  updated_at: string;
}

// Authentication state interface
export interface AuthState {
  // Current state
  user: User | null;
  profile: UserProfile | null;
  session: Session | null;
  isLoading: boolean;
  isInitialized: boolean;
  
  // Actions
  signUp: (email: string, password: string) => Promise<{ success: boolean; error?: string }>;
  signIn: (email: string, password: string) => Promise<{ success: boolean; error?: string }>;
  signOut: () => Promise<void>;
  updateProfile: (updates: Partial<Pick<UserProfile, 'username' | 'avatar_url'>>) => Promise<{ success: boolean; error?: string }>;
  initialize: () => Promise<void>;
  
  // Internal state setters
  setUser: (user: User | null) => void;
  setProfile: (profile: UserProfile | null) => void;
  setSession: (session: Session | null) => void;
  setLoading: (loading: boolean) => void;
  setInitialized: (initialized: boolean) => void;
}

export const useAuthStore = create<AuthState>((set, get) => ({
  // Initial state
  user: null,
  profile: null,
  session: null,
  isLoading: false,
  isInitialized: false,

  // Initialize auth state and set up listener
  initialize: async () => {
    console.log('🔐 Auth Store - Initializing authentication state');
    set({ isLoading: true });

    try {
      // Get current session
      const { data: { session }, error: sessionError } = await supabase.auth.getSession();
      
      if (sessionError) {
        console.error('❌ Auth Store - Session error:', sessionError);
        throw sessionError;
      }

      console.log('📱 Auth Store - Current session:', session ? 'Found' : 'None');
      
      if (session?.user) {
        // Fetch user profile
        const { data: profile, error: profileError } = await supabase
          .from('users')
          .select('*')
          .eq('id', session.user.id)
          .single();

        if (profileError && profileError.code !== 'PGRST116') {
          console.error('❌ Auth Store - Profile fetch error:', profileError);
        }

        console.log('👤 Auth Store - User profile:', profile ? 'Loaded' : 'Creating...');
        
        set({
          user: session.user,
          session: session,
          profile: profile || null,
        });
      }

      // Set up auth state change listener
      supabase.auth.onAuthStateChange(async (event, session) => {
        console.log('🔄 Auth Store - Auth state changed:', event);
        
        if (event === 'SIGNED_IN' && session?.user) {
          // Fetch or create user profile
          let { data: profile, error: profileError } = await supabase
            .from('users')
            .select('*')
            .eq('id', session.user.id)
            .single();

          if (profileError && profileError.code === 'PGRST116') {
            // Profile doesn't exist, create it
            console.log('✨ Auth Store - Creating new user profile');
            const { data: newProfile, error: createError } = await supabase
              .from('users')
              .insert({
                id: session.user.id,
                email: session.user.email!,
              })
              .select()
              .single();

            if (createError) {
              console.error('❌ Auth Store - Profile creation error:', createError);
            } else {
              profile = newProfile;
            }
          }

          set({
            user: session.user,
            session: session,
            profile: profile || null,
          });
        } else if (event === 'SIGNED_OUT') {
          console.log('👋 Auth Store - User signed out');
          set({
            user: null,
            session: null,
            profile: null,
          });
        }
      });

    } catch (error) {
      console.error('❌ Auth Store - Initialization error:', error);
    } finally {
      set({ isLoading: false, isInitialized: true });
    }
  },

  // Sign up new user
  signUp: async (email: string, password: string) => {
    console.log('📝 Auth Store - Starting user registration');
    set({ isLoading: true });

    try {
      const { data, error } = await supabase.auth.signUp({
        email,
        password,
      });

      if (error) {
        console.error('❌ Auth Store - Sign up error:', error);
        return { success: false, error: error.message };
      }

      console.log('✅ Auth Store - User registered successfully');
      return { success: true };
    } catch (error) {
      console.error('❌ Auth Store - Sign up unexpected error:', error);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Registration failed' 
      };
    } finally {
      set({ isLoading: false });
    }
  },

  // Sign in existing user
  signIn: async (email: string, password: string) => {
    console.log('🔑 Auth Store - Starting user sign in');
    set({ isLoading: true });

    try {
      const { data, error } = await supabase.auth.signInWithPassword({
        email,
        password,
      });

      if (error) {
        console.error('❌ Auth Store - Sign in error:', error);
        return { success: false, error: error.message };
      }

      console.log('✅ Auth Store - User signed in successfully');
      return { success: true };
    } catch (error) {
      console.error('❌ Auth Store - Sign in unexpected error:', error);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Sign in failed' 
      };
    } finally {
      set({ isLoading: false });
    }
  },

  // Sign out current user
  signOut: async () => {
    console.log('👋 Auth Store - Starting user sign out');
    set({ isLoading: true });

    try {
      const { error } = await supabase.auth.signOut();
      
      if (error) {
        console.error('❌ Auth Store - Sign out error:', error);
        throw error;
      }

      console.log('✅ Auth Store - User signed out successfully');
    } catch (error) {
      console.error('❌ Auth Store - Sign out unexpected error:', error);
    } finally {
      set({ isLoading: false });
    }
  },

  // Update user profile
  updateProfile: async (updates) => {
    console.log('📝 Auth Store - Updating user profile');
    const { user } = get();
    
    if (!user) {
      return { success: false, error: 'No user logged in' };
    }

    set({ isLoading: true });

    try {
      const { data, error } = await supabase
        .from('users')
        .update(updates)
        .eq('id', user.id)
        .select()
        .single();

      if (error) {
        console.error('❌ Auth Store - Profile update error:', error);
        return { success: false, error: error.message };
      }

      console.log('✅ Auth Store - Profile updated successfully');
      set({ profile: data });
      return { success: true };
    } catch (error) {
      console.error('❌ Auth Store - Profile update unexpected error:', error);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Profile update failed' 
      };
    } finally {
      set({ isLoading: false });
    }
  },

  // State setters
  setUser: (user) => set({ user }),
  setProfile: (profile) => set({ profile }),
  setSession: (session) => set({ session }),
  setLoading: (isLoading) => set({ isLoading }),
  setInitialized: (isInitialized) => set({ isInitialized }),
}));

================
File: supabase/migrations/20250101000001_auth_tables.sql
================
-- User authentication and profiles migration
-- This migration creates the users table and sets up Row Level Security (RLS) policies

-- Create users table extending auth.users
CREATE TABLE IF NOT EXISTS public.users (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  email TEXT UNIQUE NOT NULL,
  username TEXT UNIQUE,
  avatar_url TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Enable RLS on users table
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;

-- Create policies for users table
-- Users can view their own profile
CREATE POLICY "Users can view own profile" ON public.users 
FOR SELECT 
TO authenticated 
USING (auth.uid() = id);

-- Users can insert their own profile (for registration)
CREATE POLICY "Users can insert own profile" ON public.users 
FOR INSERT 
TO authenticated 
WITH CHECK (auth.uid() = id);

-- Users can update their own profile
CREATE POLICY "Users can update own profile" ON public.users 
FOR UPDATE 
TO authenticated 
USING (auth.uid() = id) 
WITH CHECK (auth.uid() = id);

-- Users can view other users profiles (needed for groups)
CREATE POLICY "Users can view other profiles" ON public.users 
FOR SELECT 
TO authenticated 
USING (true);

-- Create updated_at trigger function
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger for updated_at
CREATE TRIGGER users_updated_at
  BEFORE UPDATE ON public.users
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_updated_at();

-- Function to handle user creation
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.users (id, email)
  VALUES (NEW.id, NEW.email);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger to automatically create user profile on auth.users insert
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_new_user();

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS users_email_idx ON public.users(email);
CREATE INDEX IF NOT EXISTS users_username_idx ON public.users(username);
CREATE INDEX IF NOT EXISTS users_created_at_idx ON public.users(created_at);

-- Grant permissions
GRANT SELECT, INSERT, UPDATE ON public.users TO authenticated;
GRANT SELECT ON public.users TO anon;

================
File: tasks/prd-veo-creative-image-messenger.md
================
# VEO Creative Image Messenger
## Product Requirements Document

---

## Introduction/Overview

VEO Creative Image Messenger is an ephemeral messaging platform designed for Gen Z and millennial users who want to connect through creative, AI-enhanced conversations. The core innovation combines real-time text-to-image AI generation with ephemeral messaging - users create text prompts that transform into AI-generated images using Google's Imagen-4, which are then shared in group chats and automatically deleted after 24 hours.

**Problem Statement**: Traditional messaging apps rely on static text, photos, and emojis. Users want more creative, surprising ways to express themselves digitally without the permanence that creates social anxiety.

**Solution**: An AI-first messaging platform where creativity meets spontaneity - users send text prompts that become AI-generated images, creating unexpected, entertaining conversations that disappear after 24 hours.

---

## Goals

1. **Primary Goal**: Create a functional prototype demonstrating AI-powered ephemeral messaging with seamless text-to-image generation
2. **User Engagement**: Enable users to express creativity through AI-generated content in group conversations
3. **Technical Validation**: Prove the viability of real-time AI image generation within messaging workflows
4. **User Experience**: Deliver an intuitive, mobile-first interface that makes AI image creation accessible to non-technical users
5. **Performance**: Achieve consistent image generation within 15 seconds with >95% success rate

---

## User Stories

### Authentication & Onboarding
- **US-1**: As a new user, I want to register with email and password so I can create my account and start using the app
- **US-2**: As a returning user, I want to login with my credentials so I can access my groups and message history
- **US-3**: As a user, I want a simple onboarding flow so I understand how to create AI images from text prompts

### Group Management
- **US-4**: As a user, I want to create a new group so I can start messaging with friends
- **US-5**: As a user, I want to join existing groups so I can participate in ongoing conversations
- **US-6**: As a user, I want to see my active groups so I can choose where to send my AI-generated images

### AI Image Creation & Messaging
- **US-7**: As a user, I want to type a custom text prompt so I can generate exactly what I'm imagining
- **US-8**: As a user, I want to select from categorized prompt suggestions (style, mood, subject) so I can easily create interesting images
- **US-9**: As a user, I want to combine multiple prompt categories so I can create more complex, personalized images
- **US-10**: As a user, I want to see real-time processing status so I know when my AI image will be ready
- **US-11**: As a user, I want to send my generated image to a group so friends can see my creative expression
- **US-12**: As a user, I want to view AI-generated images from other group members so I can enjoy the creative conversation

### Ephemeral Experience
- **US-13**: As a user, I want my images to automatically delete after 24 hours so conversations stay spontaneous and anxiety-free
- **US-14**: As a user, I want to see a countdown timer on images so I know when they'll disappear

---

## Functional Requirements

### Authentication System
1. The system must provide email/password registration with basic validation
2. The system must provide secure login/logout functionality via Supabase Auth
3. The system must maintain user session state across app restarts
4. The system must allow users to create a simple profile with username and optional avatar

### Group Management
5. The system must allow users to create new groups with custom names
6. The system must enable users to join groups via invite links or group codes
7. The system must display a list of user's active groups
8. The system must support flexible group sizes (starting with small groups for testing)

### AI Image Generation
9. The system must provide a text input interface for custom prompts with character limit (500 characters)
10. The system must offer categorized prompt suggestions:
    - **Style-based**: photorealistic, cartoon style, oil painting, anime, watercolor
    - **Mood-based**: epic fantasy, cozy atmosphere, dramatic lighting, mysterious, cheerful
    - **Subject-based**: cute animals, space scenes, food photography, landscapes, portraits
11. The system must allow users to combine multiple categories in a single prompt
12. The system must integrate with Replicate API using Google's Imagen-4 model
13. The system must process text-to-image generation via Supabase Edge Functions
14. The system must provide real-time status updates during processing (queued, processing, complete, failed)
15. The system must deliver generated images within 15 seconds under normal conditions

### Messaging & Sharing
16. The system must send completed AI-generated images to selected groups
17. The system must display images in group chat interface with sender information
18. The system must show image creation timestamp and countdown to deletion
19. The system must support image viewing in full-screen mode

### Ephemeral Content Management
20. The system must automatically delete images exactly 24 hours after creation
21. The system must run cleanup processes to remove expired content from storage
22. The system must show visual countdown indicators on images approaching deletion

### Error Handling & Reliability
23. The system must implement retry mechanism for failed image generation (up to 3 attempts)
24. The system must provide fallback error messages when AI generation fails permanently
25. The system must handle network connectivity issues gracefully
26. The system must cache user data locally for offline viewing of recent messages

---

## Non-Goals (Out of Scope)

- **Content Moderation**: No automated content filtering or moderation systems
- **Advanced Group Features**: No group admin roles, member permissions, or complex group settings
- **Video Generation**: Focus only on static image generation (not video)
- **Direct Messaging**: Only group messaging, no 1-on-1 chats
- **Advanced Analytics**: No user behavior tracking or detailed analytics
- **Monetization Features**: No paid features, subscriptions, or in-app purchases
- **Desktop/Web Versions**: Mobile-only focus for prototype phase
- **Advanced AI Models**: Only Google Imagen-4, no model selection or custom training

---

## Design Considerations

### User Interface Requirements
- **Mobile-First Design**: Optimized for iOS with cross-platform compatibility
- **Playful, Creative Aesthetic**: UI should reflect the fun, experimental nature of AI art creation
- **Intuitive Prompt Building**: Simple, guided interface for combining categories and custom text
- **Clear Status Communication**: Visual indicators for AI processing states (loading, progress, completion)
- **Ephemeral Visual Language**: Design elements that emphasize temporary nature of content

### Key Screen Flows
1. **Authentication Flow**: Register → Login → Simple Profile Setup
2. **Group Creation Flow**: Groups List → Create Group → Invite/Share Group Code
3. **AI Image Creation Flow**: Select Group → Build Prompt (Categories + Custom Text) → Generate → Review → Send
4. **Group Chat Flow**: Groups List → Select Group → View Messages → Create New Image
5. **Image Viewing Flow**: Tap Image → Full Screen → Countdown Timer → Sharing Options

### Technical UI Requirements
- React Native with Expo for cross-platform development
- NativeWind/Tailwind CSS for consistent styling
- Responsive design supporting various iOS device sizes
- Smooth animations for processing states and ephemeral countdown timers

---

## Technical Considerations

### Technology Stack
- **Frontend**: React Native + Expo SDK (cross-platform with iOS focus)
- **Backend**: Supabase (PostgreSQL, Auth, Edge Functions, Realtime, Storage)
- **AI Processing**: Replicate API with Google Imagen-4 model
- **Styling**: NativeWind/Tailwind CSS
- **State Management**: Zustand for app state management

### Database Schema
```sql
-- User authentication and profiles
users (
  id UUID PRIMARY KEY,
  email TEXT UNIQUE NOT NULL,
  username TEXT UNIQUE,
  avatar_url TEXT,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Group management
groups (
  id UUID PRIMARY KEY,
  name TEXT NOT NULL,
  invite_code TEXT UNIQUE,
  created_by UUID REFERENCES users(id),
  created_at TIMESTAMP DEFAULT NOW()
);

group_members (
  group_id UUID REFERENCES groups(id),
  user_id UUID REFERENCES users(id),
  joined_at TIMESTAMP DEFAULT NOW(),
  PRIMARY KEY (group_id, user_id)
);

-- AI prompt categories and templates
prompt_categories (
  id UUID PRIMARY KEY,
  name TEXT NOT NULL,
  type TEXT NOT NULL, -- 'style', 'mood', 'subject'
  description TEXT,
  popularity_score INTEGER DEFAULT 0
);

-- Generated images and messages
ai_messages (
  id UUID PRIMARY KEY,
  user_id UUID REFERENCES users(id),
  group_id UUID REFERENCES groups(id),
  original_prompt TEXT NOT NULL,
  selected_categories UUID[],
  generated_image_url TEXT,
  processing_status TEXT DEFAULT 'pending', -- 'pending', 'processing', 'completed', 'failed'
  processing_started_at TIMESTAMP,
  processing_completed_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW(),
  expires_at TIMESTAMP DEFAULT (NOW() + INTERVAL '24 hours'),
  replicate_prediction_id TEXT
);
```

### AI Integration Architecture
- **Supabase Edge Function**: Handles Replicate API communication
- **Realtime Updates**: WebSocket connection for processing status
- **Image Storage**: Supabase Storage with automatic cleanup
- **Error Handling**: Exponential backoff retry logic

### Performance Requirements
- Image generation: 5-15 seconds typical (Google Imagen-4 performance)
- Real-time updates: <1 second latency for status changes
- Image loading: <3 seconds for generated images
- App startup: <2 seconds on iOS devices

---

## Error Handling Recommendations

### Image Generation Failures
1. **Retry Strategy**: Implement automatic retry with exponential backoff (3 attempts max)
2. **Fallback Messages**: Clear user communication when generation fails permanently
3. **Partial Success Handling**: Allow users to modify prompts and try again
4. **Network Resilience**: Queue generation requests when offline, process when reconnected

### Specific Error Scenarios
- **Prompt Too Complex**: Suggest simplifying prompt or breaking into multiple images
- **API Rate Limits**: Queue requests and notify user of expected wait time
- **Content Policy Violations**: Generic "unable to generate" message with suggestion to modify prompt
- **Service Unavailable**: Temporary service message with retry option

### User Experience During Errors
- Clear error messages without technical jargon
- Actionable next steps for users
- Option to save prompts and retry later
- Graceful degradation when AI service is unavailable

---

## Success Metrics

### Technical Success Criteria
- **Generation Success Rate**: >95% of prompts successfully generate images
- **Processing Time**: Average generation time <10 seconds
- **System Uptime**: >99% availability during testing phase
- **Error Recovery**: >80% of failed generations succeed on retry

### User Experience Success Criteria
- **User Onboarding**: >80% of users complete registration and send first AI image
- **Feature Adoption**: >70% of users try prompt categories within first session
- **Engagement**: Users create average 5+ images per session
- **Retention**: >60% of users return within 48 hours for second session

### Business/Product Success Criteria
- **Core Functionality**: All 14 functional requirements fully implemented
- **Platform Stability**: App runs without crashes on target iOS devices
- **Scalability Readiness**: Architecture supports scaling to 100+ concurrent users
- **Demo Readiness**: Fully functional prototype suitable for investor/stakeholder demos

---

## Open Questions

1. **Prompt Optimization**: Should we implement prompt enhancement suggestions to improve generation success rates?
2. **Storage Costs**: With 24-hour ephemeral content, what's the optimal storage cleanup frequency?
3. **User Feedback**: Should we collect user ratings on generated images to improve prompt suggestions?
4. **Offline Experience**: How much functionality should be available when users are offline?
5. **Group Discovery**: Do we need any mechanism for users to discover and join public groups?
6. **Image Quality Settings**: Should users have options for generation speed vs. quality trade-offs?
7. **Notification Strategy**: What notifications should users receive for new AI images in their groups?

---

## Implementation Priority

### Phase 1 (MVP - Weeks 1-2)
- User authentication and basic profiles
- Simple group creation and joining
- Basic text prompt input and AI generation
- Core messaging interface

### Phase 2 (Enhanced Features - Weeks 3-4)
- Prompt categories and suggestions
- Real-time processing status
- Ephemeral content deletion
- Error handling and retry logic

### Phase 3 (Polish & Testing - Week 5)
- UI/UX refinements
- Performance optimization
- Comprehensive testing
- Demo preparation

================
File: tasks/tasks-prd-veo-creative-image-messenger.md
================
# VEO Creative Image Messenger - Task List
Based on PRD: `prd-veo-creative-image-messenger.md`

## Relevant Files

- `app/(auth)/login.tsx` - Login screen with email/password authentication
- `app/(auth)/register.tsx` - User registration screen with validation
- `app/(auth)/profile-setup.tsx` - Initial profile creation screen
- `app/(auth)/_layout.tsx` - Auth stack navigation layout
- `app/(tabs)/groups.tsx` - Groups list and management screen
- `app/(tabs)/create-group.tsx` - Group creation interface
- `app/group/[id].tsx` - Individual group chat screen
- `app/create-image.tsx` - AI image generation interface
- `components/auth/AuthForm.tsx` - Reusable authentication form components
- `components/groups/GroupCard.tsx` - Group display component
- `components/groups/GroupMembersList.tsx` - Group members management
- `components/ai/PromptInput.tsx` - Text prompt input component
- `components/ai/CategorySelector.tsx` - Prompt category selection
- `components/ai/ProcessingStatus.tsx` - Real-time processing indicator
- `components/messaging/MessageBubble.tsx` - Chat message display component
- `components/messaging/ImageMessage.tsx` - AI-generated image message component
- `components/messaging/CountdownTimer.tsx` - 24-hour deletion countdown
- `lib/auth.ts` - Authentication utilities and session management
- `lib/groups.ts` - Group management functions
- `lib/ai-generation.ts` - AI image generation service integration
- `lib/supabase-client.ts` - Enhanced Supabase client configuration
- `lib/replicate.ts` - Replicate API integration utilities
- `lib/storage.ts` - Image storage and cleanup functions
- `lib/realtime.ts` - Real-time updates handling
- `store/authStore.ts` - Zustand auth state management
- `store/groupsStore.ts` - Zustand groups state management
- `store/messagesStore.ts` - Zustand messages state management
- `supabase/functions/generate-image/index.ts` - Edge function for AI processing
- `supabase/functions/cleanup-expired/index.ts` - Automated content cleanup
- `supabase/migrations/20250101000001_auth_tables.sql` - User authentication tables
- `supabase/migrations/20250101000002_groups_tables.sql` - Group management tables
- `supabase/migrations/20250101000003_messages_tables.sql` - AI messages and content tables
- `supabase/migrations/20250101000004_prompt_categories.sql` - Prompt categories and templates

### Notes

- All auth screens should be placed in `app/(auth)/` directory for proper navigation flow
- Group-related screens use both tabs navigation and dynamic routing for individual groups
- AI generation components are modular and reusable across different screens
- Supabase Edge Functions handle server-side AI processing to keep API keys secure
- State management with Zustand provides reactive updates across the app
- Database migrations follow timestamp naming convention for proper ordering
- Real-time functionality uses Supabase Realtime for instant status updates

## Tasks

- [ ] 1.0 Authentication & User Management System
  - [x] 1.1 Configure Supabase Auth settings and policies in Supabase dashboard
  - [ ] 1.2 Create auth navigation stack with login/register/profile-setup screens
  - [ ] 1.3 Build reusable AuthForm component with email/password validation
  - [ ] 1.4 Implement user registration with email verification and error handling
  - [ ] 1.5 Create login functionality with session persistence
  - [ ] 1.6 Build profile setup screen for username and optional avatar
  - [ ] 1.7 Set up Zustand auth store for global authentication state
  - [ ] 1.8 Implement automatic session restoration on app launch
  - [ ] 1.9 Create user database migration and RLS policies

- [ ] 2.0 Group Management & Navigation
  - [ ] 2.1 Create groups database migration with proper relationships
  - [ ] 2.2 Build groups list screen showing user's active groups
  - [ ] 2.3 Implement group creation screen with name input and invite code generation
  - [ ] 2.4 Create group joining functionality via invite codes or links
  - [ ] 2.5 Build GroupCard component for consistent group display
  - [ ] 2.6 Set up dynamic routing for individual group screens
  - [ ] 2.7 Implement group members management and display
  - [ ] 2.8 Create Zustand groups store for state management
  - [ ] 2.9 Add RLS policies for secure group access control

- [ ] 3.0 AI Image Generation & Processing Pipeline
  - [ ] 3.1 Set up Replicate API account and obtain API keys
  - [ ] 3.2 Create prompt categories database migration with seed data
  - [ ] 3.3 Build PromptInput component with character limit and validation
  - [ ] 3.4 Create CategorySelector component for style/mood/subject categories
  - [ ] 3.5 Implement category combination logic and prompt building
  - [ ] 3.6 Create Supabase Edge Function for secure Replicate API integration
  - [ ] 3.7 Build ProcessingStatus component with real-time updates
  - [ ] 3.8 Set up Supabase Realtime subscriptions for processing status
  - [ ] 3.9 Implement image generation workflow from prompt to completion
  - [ ] 3.10 Create AI messages database migration with status tracking
  - [ ] 3.11 Set up image storage in Supabase Storage with proper naming

- [ ] 4.0 Messaging Interface & Ephemeral Content Management
  - [ ] 4.1 Build group chat screen layout with message list
  - [ ] 4.2 Create MessageBubble component for text and system messages
  - [ ] 4.3 Build ImageMessage component for AI-generated content display
  - [ ] 4.4 Implement full-screen image viewing with zoom capabilities
  - [ ] 4.5 Create CountdownTimer component showing time until deletion
  - [ ] 4.6 Set up 24-hour automatic deletion system via scheduled function
  - [ ] 4.7 Build expired content cleanup Edge Function
  - [ ] 4.8 Implement real-time message synchronization across group members
  - [ ] 4.9 Create messages Zustand store for chat state management
  - [ ] 4.10 Add visual indicators for ephemeral content lifecycle

- [ ] 5.0 Error Handling & System Reliability
  - [ ] 5.1 Implement retry mechanism for failed AI generation (3 attempts max)
  - [ ] 5.2 Create comprehensive error handling for network connectivity issues
  - [ ] 5.3 Build fallback UI states for when AI generation fails permanently
  - [ ] 5.4 Set up offline data caching for recent messages and groups
  - [ ] 5.5 Implement graceful degradation when Replicate API is unavailable
  - [ ] 5.6 Create user-friendly error messages without technical jargon
  - [ ] 5.7 Add loading states and progress indicators throughout the app
  - [ ] 5.8 Implement exponential backoff for API rate limiting scenarios
  - [ ] 5.9 Set up error logging and monitoring for debugging
  - [ ] 5.10 Create recovery mechanisms for partial failures and interrupted processes

================
File: app/(tabs)/explore.tsx
================
import { Image } from 'expo-image';
import { Platform, StyleSheet } from 'react-native';

import { Collapsible } from '@/components/Collapsible';
import { ExternalLink } from '@/components/ExternalLink';
import ParallaxScrollView from '@/components/ParallaxScrollView';
import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';
import { IconSymbol } from '@/components/ui/IconSymbol';

export default function TabTwoScreen() {
  return (
    <ParallaxScrollView
      headerBackgroundColor={{ light: '#D0D0D0', dark: '#353636' }}
      headerImage={
        <IconSymbol
          size={310}
          color="#808080"
          name="chevron.left.forwardslash.chevron.right"
          style={styles.headerImage}
        />
      }>
      <ThemedView style={styles.titleContainer}>
        <ThemedText type="title">Explore</ThemedText>
      </ThemedView>
      <ThemedText>This app includes example code to help you get started.</ThemedText>
      <Collapsible title="File-based routing">
        <ThemedText>
          This app has two screens:{' '}
          <ThemedText type="defaultSemiBold">app/(tabs)/index.tsx</ThemedText> and{' '}
          <ThemedText type="defaultSemiBold">app/(tabs)/explore.tsx</ThemedText>
        </ThemedText>
        <ThemedText>
          The layout file in <ThemedText type="defaultSemiBold">app/(tabs)/_layout.tsx</ThemedText>{' '}
          sets up the tab navigator.
        </ThemedText>
        <ExternalLink href="https://docs.expo.dev/router/introduction">
          <ThemedText type="link">Learn more</ThemedText>
        </ExternalLink>
      </Collapsible>
      <Collapsible title="Android, iOS, and web support">
        <ThemedText>
          You can open this project on Android, iOS, and the web. To open the web version, press{' '}
          <ThemedText type="defaultSemiBold">w</ThemedText> in the terminal running this project.
        </ThemedText>
      </Collapsible>
      <Collapsible title="Images">
        <ThemedText>
          For static images, you can use the <ThemedText type="defaultSemiBold">@2x</ThemedText> and{' '}
          <ThemedText type="defaultSemiBold">@3x</ThemedText> suffixes to provide files for
          different screen densities
        </ThemedText>
        <Image source={require('@/assets/images/react-logo.png')} style={{ alignSelf: 'center' }} />
        <ExternalLink href="https://reactnative.dev/docs/images">
          <ThemedText type="link">Learn more</ThemedText>
        </ExternalLink>
      </Collapsible>
      <Collapsible title="Custom fonts">
        <ThemedText>
          Open <ThemedText type="defaultSemiBold">app/_layout.tsx</ThemedText> to see how to load{' '}
          <ThemedText style={{ fontFamily: 'SpaceMono' }}>
            custom fonts such as this one.
          </ThemedText>
        </ThemedText>
        <ExternalLink href="https://docs.expo.dev/versions/latest/sdk/font">
          <ThemedText type="link">Learn more</ThemedText>
        </ExternalLink>
      </Collapsible>
      <Collapsible title="Light and dark mode components">
        <ThemedText>
          This template has light and dark mode support. The{' '}
          <ThemedText type="defaultSemiBold">useColorScheme()</ThemedText> hook lets you inspect
          what the user&apos;s current color scheme is, and so you can adjust UI colors accordingly.
        </ThemedText>
        <ExternalLink href="https://docs.expo.dev/develop/user-interface/color-themes/">
          <ThemedText type="link">Learn more</ThemedText>
        </ExternalLink>
      </Collapsible>
      <Collapsible title="Animations">
        <ThemedText>
          This template includes an example of an animated component. The{' '}
          <ThemedText type="defaultSemiBold">components/HelloWave.tsx</ThemedText> component uses
          the powerful <ThemedText type="defaultSemiBold">react-native-reanimated</ThemedText>{' '}
          library to create a waving hand animation.
        </ThemedText>
        {Platform.select({
          ios: (
            <ThemedText>
              The <ThemedText type="defaultSemiBold">components/ParallaxScrollView.tsx</ThemedText>{' '}
              component provides a parallax effect for the header image.
            </ThemedText>
          ),
        })}
      </Collapsible>
    </ParallaxScrollView>
  );
}

const styles = StyleSheet.create({
  headerImage: {
    color: '#808080',
    bottom: -90,
    left: -35,
    position: 'absolute',
  },
  titleContainer: {
    flexDirection: 'row',
    gap: 8,
  },
});

================
File: app/+not-found.tsx
================
import { Link, Stack } from 'expo-router';
import { StyleSheet } from 'react-native';

import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';

export default function NotFoundScreen() {
  return (
    <>
      <Stack.Screen options={{ title: 'Oops!' }} />
      <ThemedView style={styles.container}>
        <ThemedText type="title">This screen does not exist.</ThemedText>
        <Link href="/" style={styles.link}>
          <ThemedText type="link">Go to home screen!</ThemedText>
        </Link>
      </ThemedView>
    </>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
  },
  link: {
    marginTop: 15,
    paddingVertical: 15,
  },
});

================
File: components/ui/IconSymbol.ios.tsx
================
import { SymbolView, SymbolViewProps, SymbolWeight } from 'expo-symbols';
import { StyleProp, ViewStyle } from 'react-native';

export function IconSymbol({
  name,
  size = 24,
  color,
  style,
  weight = 'regular',
}: {
  name: SymbolViewProps['name'];
  size?: number;
  color: string;
  style?: StyleProp<ViewStyle>;
  weight?: SymbolWeight;
}) {
  return (
    <SymbolView
      weight={weight}
      tintColor={color}
      resizeMode="scaleAspectFit"
      name={name}
      style={[
        {
          width: size,
          height: size,
        },
        style,
      ]}
    />
  );
}

================
File: components/ui/TabBarBackground.ios.tsx
================
import { useBottomTabBarHeight } from '@react-navigation/bottom-tabs';
import { BlurView } from 'expo-blur';
import { StyleSheet } from 'react-native';

export default function BlurTabBarBackground() {
  return (
    <BlurView
      // System chrome material automatically adapts to the system's theme
      // and matches the native tab bar appearance on iOS.
      tint="systemChromeMaterial"
      intensity={100}
      style={StyleSheet.absoluteFill}
    />
  );
}

export function useBottomTabOverflow() {
  return useBottomTabBarHeight();
}

================
File: components/ui/TabBarBackground.tsx
================
// This is a shim for web and Android where the tab bar is generally opaque.
export default undefined;

export function useBottomTabOverflow() {
  return 0;
}

================
File: components/Collapsible.tsx
================
import { PropsWithChildren, useState } from 'react';
import { StyleSheet, TouchableOpacity } from 'react-native';

import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';
import { IconSymbol } from '@/components/ui/IconSymbol';
import { Colors } from '@/constants/Colors';
import { useColorScheme } from '@/hooks/useColorScheme';

export function Collapsible({ children, title }: PropsWithChildren & { title: string }) {
  const [isOpen, setIsOpen] = useState(false);
  const theme = useColorScheme() ?? 'light';

  return (
    <ThemedView>
      <TouchableOpacity
        style={styles.heading}
        onPress={() => setIsOpen((value) => !value)}
        activeOpacity={0.8}>
        <IconSymbol
          name="chevron.right"
          size={18}
          weight="medium"
          color={theme === 'light' ? Colors.light.icon : Colors.dark.icon}
          style={{ transform: [{ rotate: isOpen ? '90deg' : '0deg' }] }}
        />

        <ThemedText type="defaultSemiBold">{title}</ThemedText>
      </TouchableOpacity>
      {isOpen && <ThemedView style={styles.content}>{children}</ThemedView>}
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  heading: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
  },
  content: {
    marginTop: 6,
    marginLeft: 24,
  },
});

================
File: components/ExternalLink.tsx
================
import { Href, Link } from 'expo-router';
import { openBrowserAsync } from 'expo-web-browser';
import { type ComponentProps } from 'react';
import { Platform } from 'react-native';

type Props = Omit<ComponentProps<typeof Link>, 'href'> & { href: Href & string };

export function ExternalLink({ href, ...rest }: Props) {
  return (
    <Link
      target="_blank"
      {...rest}
      href={href}
      onPress={async (event) => {
        if (Platform.OS !== 'web') {
          // Prevent the default behavior of linking to the default browser on native.
          event.preventDefault();
          // Open the link in an in-app browser.
          await openBrowserAsync(href);
        }
      }}
    />
  );
}

================
File: components/HapticTab.tsx
================
import { BottomTabBarButtonProps } from '@react-navigation/bottom-tabs';
import { PlatformPressable } from '@react-navigation/elements';
import * as Haptics from 'expo-haptics';

export function HapticTab(props: BottomTabBarButtonProps) {
  return (
    <PlatformPressable
      {...props}
      onPressIn={(ev) => {
        if (process.env.EXPO_OS === 'ios') {
          // Add a soft haptic feedback when pressing down on the tabs.
          Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
        }
        props.onPressIn?.(ev);
      }}
    />
  );
}

================
File: components/HelloWave.tsx
================
import { useEffect } from 'react';
import { StyleSheet } from 'react-native';
import Animated, {
  useAnimatedStyle,
  useSharedValue,
  withRepeat,
  withSequence,
  withTiming,
} from 'react-native-reanimated';

import { ThemedText } from '@/components/ThemedText';

export function HelloWave() {
  const rotationAnimation = useSharedValue(0);

  useEffect(() => {
    rotationAnimation.value = withRepeat(
      withSequence(withTiming(25, { duration: 150 }), withTiming(0, { duration: 150 })),
      4 // Run the animation 4 times
    );
  }, [rotationAnimation]);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ rotate: `${rotationAnimation.value}deg` }],
  }));

  return (
    <Animated.View style={animatedStyle}>
      <ThemedText style={styles.text}>👋</ThemedText>
    </Animated.View>
  );
}

const styles = StyleSheet.create({
  text: {
    fontSize: 28,
    lineHeight: 32,
    marginTop: -6,
  },
});

================
File: components/ParallaxScrollView.tsx
================
import type { PropsWithChildren, ReactElement } from 'react';
import { StyleSheet } from 'react-native';
import Animated, {
  interpolate,
  useAnimatedRef,
  useAnimatedStyle,
  useScrollViewOffset,
} from 'react-native-reanimated';

import { ThemedView } from '@/components/ThemedView';
import { useBottomTabOverflow } from '@/components/ui/TabBarBackground';
import { useColorScheme } from '@/hooks/useColorScheme';

const HEADER_HEIGHT = 250;

type Props = PropsWithChildren<{
  headerImage: ReactElement;
  headerBackgroundColor: { dark: string; light: string };
}>;

export default function ParallaxScrollView({
  children,
  headerImage,
  headerBackgroundColor,
}: Props) {
  const colorScheme = useColorScheme() ?? 'light';
  const scrollRef = useAnimatedRef<Animated.ScrollView>();
  const scrollOffset = useScrollViewOffset(scrollRef);
  const bottom = useBottomTabOverflow();
  const headerAnimatedStyle = useAnimatedStyle(() => {
    return {
      transform: [
        {
          translateY: interpolate(
            scrollOffset.value,
            [-HEADER_HEIGHT, 0, HEADER_HEIGHT],
            [-HEADER_HEIGHT / 2, 0, HEADER_HEIGHT * 0.75]
          ),
        },
        {
          scale: interpolate(scrollOffset.value, [-HEADER_HEIGHT, 0, HEADER_HEIGHT], [2, 1, 1]),
        },
      ],
    };
  });

  return (
    <ThemedView style={styles.container}>
      <Animated.ScrollView
        ref={scrollRef}
        scrollEventThrottle={16}
        scrollIndicatorInsets={{ bottom }}
        contentContainerStyle={{ paddingBottom: bottom }}>
        <Animated.View
          style={[
            styles.header,
            { backgroundColor: headerBackgroundColor[colorScheme] },
            headerAnimatedStyle,
          ]}>
          {headerImage}
        </Animated.View>
        <ThemedView style={styles.content}>{children}</ThemedView>
      </Animated.ScrollView>
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    height: HEADER_HEIGHT,
    overflow: 'hidden',
  },
  content: {
    flex: 1,
    padding: 32,
    gap: 16,
    overflow: 'hidden',
  },
});

================
File: components/ThemedText.tsx
================
import { StyleSheet, Text, type TextProps } from 'react-native';

import { useThemeColor } from '@/hooks/useThemeColor';

export type ThemedTextProps = TextProps & {
  lightColor?: string;
  darkColor?: string;
  type?: 'default' | 'title' | 'defaultSemiBold' | 'subtitle' | 'link';
};

export function ThemedText({
  style,
  lightColor,
  darkColor,
  type = 'default',
  ...rest
}: ThemedTextProps) {
  const color = useThemeColor({ light: lightColor, dark: darkColor }, 'text');

  return (
    <Text
      style={[
        { color },
        type === 'default' ? styles.default : undefined,
        type === 'title' ? styles.title : undefined,
        type === 'defaultSemiBold' ? styles.defaultSemiBold : undefined,
        type === 'subtitle' ? styles.subtitle : undefined,
        type === 'link' ? styles.link : undefined,
        style,
      ]}
      {...rest}
    />
  );
}

const styles = StyleSheet.create({
  default: {
    fontSize: 16,
    lineHeight: 24,
  },
  defaultSemiBold: {
    fontSize: 16,
    lineHeight: 24,
    fontWeight: '600',
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    lineHeight: 32,
  },
  subtitle: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  link: {
    lineHeight: 30,
    fontSize: 16,
    color: '#0a7ea4',
  },
});

================
File: components/ThemedView.tsx
================
import { View, type ViewProps } from 'react-native';

import { useThemeColor } from '@/hooks/useThemeColor';

export type ThemedViewProps = ViewProps & {
  lightColor?: string;
  darkColor?: string;
};

export function ThemedView({ style, lightColor, darkColor, ...otherProps }: ThemedViewProps) {
  const backgroundColor = useThemeColor({ light: lightColor, dark: darkColor }, 'background');

  return <View style={[{ backgroundColor }, style]} {...otherProps} />;
}

================
File: constants/Colors.ts
================
/**
 * Below are the colors that are used in the app. The colors are defined in the light and dark mode.
 * There are many other ways to style your app. For example, [Nativewind](https://www.nativewind.dev/), [Tamagui](https://tamagui.dev/), [unistyles](https://reactnativeunistyles.vercel.app), etc.
 */

const tintColorLight = '#0a7ea4';
const tintColorDark = '#fff';

export const Colors = {
  light: {
    text: '#11181C',
    background: '#fff',
    tint: tintColorLight,
    icon: '#687076',
    tabIconDefault: '#687076',
    tabIconSelected: tintColorLight,
  },
  dark: {
    text: '#ECEDEE',
    background: '#151718',
    tint: tintColorDark,
    icon: '#9BA1A6',
    tabIconDefault: '#9BA1A6',
    tabIconSelected: tintColorDark,
  },
};

================
File: hooks/useColorScheme.ts
================
export { useColorScheme } from 'react-native';

================
File: hooks/useColorScheme.web.ts
================
import { useEffect, useState } from 'react';
import { useColorScheme as useRNColorScheme } from 'react-native';

/**
 * To support static rendering, this value needs to be re-calculated on the client side for web
 */
export function useColorScheme() {
  const [hasHydrated, setHasHydrated] = useState(false);

  useEffect(() => {
    setHasHydrated(true);
  }, []);

  const colorScheme = useRNColorScheme();

  if (hasHydrated) {
    return colorScheme;
  }

  return 'light';
}

================
File: hooks/useThemeColor.ts
================
/**
 * Learn more about light and dark modes:
 * https://docs.expo.dev/guides/color-schemes/
 */

import { Colors } from '@/constants/Colors';
import { useColorScheme } from '@/hooks/useColorScheme';

export function useThemeColor(
  props: { light?: string; dark?: string },
  colorName: keyof typeof Colors.light & keyof typeof Colors.dark
) {
  const theme = useColorScheme() ?? 'light';
  const colorFromProps = props[theme];

  if (colorFromProps) {
    return colorFromProps;
  } else {
    return Colors[theme][colorName];
  }
}

================
File: lib/photoService.ts
================
/**
 * Photo Service
 * 
 * This service handles all photo-related operations including:
 * - Uploading images to Supabase Storage
 * - Saving photo metadata to the database
 * - Retrieving photos and generating public URLs
 */

import { decode } from 'base64-arraybuffer';
import * as FileSystem from 'expo-file-system';
import { Photo, supabase } from './supabase';

/**
 * Upload result interface
 */
export interface PhotoUploadResult {
  success: boolean;
  photo?: Photo;
  error?: string;
  publicUrl?: string;
}

/**
 * Photo upload options
 */
export interface PhotoUploadOptions {
  userId?: string;
  quality?: number;
  generateThumbnail?: boolean;
}

/**
 * Generate a unique filename for the photo
 */
function generateUniqueFileName(originalName?: string): string {
  const timestamp = Date.now();
  const randomStr = Math.random().toString(36).substring(2, 15);
  const extension = originalName?.split('.').pop() || 'jpg';
  
  return `photo_${timestamp}_${randomStr}.${extension}`;
}

/**
 * Get file size from URI
 */
async function getFileSize(uri: string): Promise<number> {
  try {
    console.log('📏 Photo Service - Getting file size for:', uri);
    const fileInfo = await FileSystem.getInfoAsync(uri);
    
    if (fileInfo.exists && 'size' in fileInfo) {
      console.log('✅ Photo Service - File size:', fileInfo.size, 'bytes');
      return fileInfo.size;
    }
    
    console.log('⚠️ Photo Service - Could not determine file size, defaulting to 0');
    return 0;
  } catch (error) {
    console.error('❌ Photo Service - Error getting file size:', error);
    return 0;
  }
}

/**
 * Determine MIME type from file extension
 */
function getMimeType(fileName: string): string {
  const extension = fileName.split('.').pop()?.toLowerCase();
  
  const mimeTypes: { [key: string]: string } = {
    'jpg': 'image/jpeg',
    'jpeg': 'image/jpeg',
    'png': 'image/png',
    'webp': 'image/webp',
    'heic': 'image/heic',
    'heif': 'image/heif',
  };
  
  return mimeTypes[extension || 'jpg'] || 'image/jpeg';
}

/**
 * Upload photo to Supabase Storage and save metadata to database
 */
export async function uploadPhoto(
  photoUri: string,
  options: PhotoUploadOptions = {}
): Promise<PhotoUploadResult> {
  console.log('📤 Photo Service - Starting photo upload process');
  console.log('📍 Photo URI:', photoUri);
  console.log('⚙️ Upload options:', options);

  try {
    // Generate unique filename
    const fileName = generateUniqueFileName();
    const filePath = `uploads/${fileName}`;
    
    console.log('📝 Photo Service - Generated filename:', fileName);
    console.log('📂 Photo Service - File path:', filePath);

    // Get file info
    const fileSize = await getFileSize(photoUri);
    const mimeType = getMimeType(fileName);
    
    console.log('📊 Photo Service - File details:');
    console.log('  - Size:', fileSize, 'bytes');
    console.log('  - MIME type:', mimeType);

    // Read file as base64
    console.log('📖 Photo Service - Reading file as base64');
    const base64Response = await FileSystem.readAsStringAsync(photoUri, {
      encoding: FileSystem.EncodingType.Base64,
    });

    // Convert base64 to ArrayBuffer
    console.log('🔄 Photo Service - Converting base64 to ArrayBuffer');
    const arrayBuffer = decode(base64Response);

    // Upload to Supabase Storage
    console.log('☁️ Photo Service - Uploading to Supabase Storage');
    const { data: uploadData, error: uploadError } = await supabase.storage
      .from('photos')
      .upload(filePath, arrayBuffer, {
        contentType: mimeType,
        cacheControl: '3600', // Cache for 1 hour
        upsert: false, // Don't overwrite existing files
      });

    if (uploadError) {
      console.error('❌ Photo Service - Storage upload error:', uploadError);
      return {
        success: false,
        error: `Failed to upload file: ${uploadError.message}`,
      };
    }

    console.log('✅ Photo Service - File uploaded successfully');
    console.log('📁 Upload data:', uploadData);

    // Get public URL
    console.log('🔗 Photo Service - Generating public URL');
    const { data: urlData } = supabase.storage
      .from('photos')
      .getPublicUrl(filePath);

    const publicUrl = urlData.publicUrl;
    console.log('🌐 Photo Service - Public URL:', publicUrl);

    // Prepare photo metadata for database
    const photoMetadata = {
      user_id: options.userId || null,
      file_name: fileName,
      file_path: filePath,
      file_size: fileSize,
      mime_type: mimeType,
      taken_at: new Date().toISOString(),
      storage_bucket: 'photos',
      public_url: publicUrl,
    };

    console.log('💾 Photo Service - Saving metadata to database');
    console.log('📊 Photo metadata:', photoMetadata);

    // Save metadata to database
    const { data: dbData, error: dbError } = await supabase
      .from('photos')
      .insert(photoMetadata)
      .select()
      .single();

    if (dbError) {
      console.error('❌ Photo Service - Database error:', dbError);
      
      // Cleanup: delete the uploaded file if database save failed
      console.log('🧹 Photo Service - Cleaning up uploaded file due to database error');
      await supabase.storage.from('photos').remove([filePath]);
      
      return {
        success: false,
        error: `Failed to save photo metadata: ${dbError.message}`,
      };
    }

    console.log('✅ Photo Service - Photo uploaded and saved successfully!');
    console.log('📊 Saved photo data:', dbData);

    return {
      success: true,
      photo: dbData as Photo,
      publicUrl: publicUrl,
    };

  } catch (error) {
    console.error('❌ Photo Service - Unexpected error during upload:', error);
    return {
      success: false,
      error: `Unexpected error: ${error instanceof Error ? error.message : 'Unknown error'}`,
    };
  }
}

/**
 * Get all photos from the database
 */
export async function getAllPhotos(): Promise<Photo[]> {
  console.log('📋 Photo Service - Fetching all photos');

  try {
    const { data, error } = await supabase
      .from('photos')
      .select('*')
      .order('taken_at', { ascending: false });

    if (error) {
      console.error('❌ Photo Service - Error fetching photos:', error);
      throw new Error(`Failed to fetch photos: ${error.message}`);
    }

    console.log('✅ Photo Service - Successfully fetched', data?.length || 0, 'photos');
    return data || [];

  } catch (error) {
    console.error('❌ Photo Service - Unexpected error fetching photos:', error);
    return [];
  }
}

/**
 * Get photos by user ID
 */
export async function getPhotosByUser(userId: string): Promise<Photo[]> {
  console.log('👤 Photo Service - Fetching photos for user:', userId);

  try {
    const { data, error } = await supabase
      .from('photos')
      .select('*')
      .eq('user_id', userId)
      .order('taken_at', { ascending: false });

    if (error) {
      console.error('❌ Photo Service - Error fetching user photos:', error);
      throw new Error(`Failed to fetch user photos: ${error.message}`);
    }

    console.log('✅ Photo Service - Successfully fetched', data?.length || 0, 'photos for user');
    return data || [];

  } catch (error) {
    console.error('❌ Photo Service - Unexpected error fetching user photos:', error);
    return [];
  }
}

/**
 * Delete a photo (both from storage and database)
 */
export async function deletePhoto(photoId: string): Promise<boolean> {
  console.log('🗑️ Photo Service - Deleting photo with ID:', photoId);

  try {
    // First, get the photo data to know the file path
    const { data: photo, error: fetchError } = await supabase
      .from('photos')
      .select('file_path')
      .eq('id', photoId)
      .single();

    if (fetchError || !photo) {
      console.error('❌ Photo Service - Error fetching photo for deletion:', fetchError);
      return false;
    }

    console.log('📁 Photo Service - File path to delete:', photo.file_path);

    // Delete from storage
    const { error: storageError } = await supabase.storage
      .from('photos')
      .remove([photo.file_path]);

    if (storageError) {
      console.error('❌ Photo Service - Error deleting from storage:', storageError);
      // Continue with database deletion even if storage deletion fails
    } else {
      console.log('✅ Photo Service - Successfully deleted from storage');
    }

    // Delete from database
    const { error: dbError } = await supabase
      .from('photos')
      .delete()
      .eq('id', photoId);

    if (dbError) {
      console.error('❌ Photo Service - Error deleting from database:', dbError);
      return false;
    }

    console.log('✅ Photo Service - Successfully deleted photo');
    return true;

  } catch (error) {
    console.error('❌ Photo Service - Unexpected error deleting photo:', error);
    return false;
  }
}

================
File: lib/supabase.ts
================
/**
 * Supabase Client Configuration
 * 
 * This file configures the Supabase client for the SnapClone application.
 * It handles authentication, database operations, and storage functionality.
 */

import { createClient } from '@supabase/supabase-js';
import Constants from 'expo-constants';

// Get environment variables from Expo Constants
const supabaseUrl = Constants.expoConfig?.extra?.EXPO_PUBLIC_SUPABASE_URL || process.env.EXPO_PUBLIC_SUPABASE_URL;
const supabaseAnonKey = Constants.expoConfig?.extra?.EXPO_PUBLIC_SUPABASE_ANON_KEY || process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY;

console.log('🔧 Supabase Config - Initializing client');
console.log('📍 Supabase URL:', supabaseUrl ? 'Set ✓' : 'Missing ❌');
console.log('🔑 Supabase Anon Key:', supabaseAnonKey ? 'Set ✓' : 'Missing ❌');

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error(
    'Missing Supabase environment variables. Please check your .env file contains:\n' +
    '- EXPO_PUBLIC_SUPABASE_URL\n' +
    '- EXPO_PUBLIC_SUPABASE_ANON_KEY'
  );
}

/**
 * Supabase client instance
 * Configured with auto-refresh for authentication and proper URL handling
 */
export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    // Enable auto refresh of auth tokens
    autoRefreshToken: true,
    // Persist auth state in local storage
    persistSession: true,
    // Detect auth state changes
    detectSessionInUrl: false,
  },
});

/**
 * Database Types for TypeScript support
 */
export interface Photo {
  id: string;
  user_id?: string;
  file_name: string;
  file_path: string;
  file_size: number;
  mime_type: string;
  width?: number;
  height?: number;
  taken_at: string;
  uploaded_at: string;
  storage_bucket: string;
  public_url?: string;
}

export interface Database {
  public: {
    Tables: {
      photos: {
        Row: Photo;
        Insert: Omit<Photo, 'id' | 'uploaded_at'>;
        Update: Partial<Omit<Photo, 'id' | 'uploaded_at'>>;
      };
    };
  };
}

console.log('✅ Supabase client initialized successfully');

================
File: scripts/reset-project.js
================
#!/usr/bin/env node

/**
 * This script is used to reset the project to a blank state.
 * It deletes or moves the /app, /components, /hooks, /scripts, and /constants directories to /app-example based on user input and creates a new /app directory with an index.tsx and _layout.tsx file.
 * You can remove the `reset-project` script from package.json and safely delete this file after running it.
 */

const fs = require("fs");
const path = require("path");
const readline = require("readline");

const root = process.cwd();
const oldDirs = ["app", "components", "hooks", "constants", "scripts"];
const exampleDir = "app-example";
const newAppDir = "app";
const exampleDirPath = path.join(root, exampleDir);

const indexContent = `import { Text, View } from "react-native";

export default function Index() {
  return (
    <View
      style={{
        flex: 1,
        justifyContent: "center",
        alignItems: "center",
      }}
    >
      <Text>Edit app/index.tsx to edit this screen.</Text>
    </View>
  );
}
`;

const layoutContent = `import { Stack } from "expo-router";

export default function RootLayout() {
  return <Stack />;
}
`;

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

const moveDirectories = async (userInput) => {
  try {
    if (userInput === "y") {
      // Create the app-example directory
      await fs.promises.mkdir(exampleDirPath, { recursive: true });
      console.log(`📁 /${exampleDir} directory created.`);
    }

    // Move old directories to new app-example directory or delete them
    for (const dir of oldDirs) {
      const oldDirPath = path.join(root, dir);
      if (fs.existsSync(oldDirPath)) {
        if (userInput === "y") {
          const newDirPath = path.join(root, exampleDir, dir);
          await fs.promises.rename(oldDirPath, newDirPath);
          console.log(`➡️ /${dir} moved to /${exampleDir}/${dir}.`);
        } else {
          await fs.promises.rm(oldDirPath, { recursive: true, force: true });
          console.log(`❌ /${dir} deleted.`);
        }
      } else {
        console.log(`➡️ /${dir} does not exist, skipping.`);
      }
    }

    // Create new /app directory
    const newAppDirPath = path.join(root, newAppDir);
    await fs.promises.mkdir(newAppDirPath, { recursive: true });
    console.log("\n📁 New /app directory created.");

    // Create index.tsx
    const indexPath = path.join(newAppDirPath, "index.tsx");
    await fs.promises.writeFile(indexPath, indexContent);
    console.log("📄 app/index.tsx created.");

    // Create _layout.tsx
    const layoutPath = path.join(newAppDirPath, "_layout.tsx");
    await fs.promises.writeFile(layoutPath, layoutContent);
    console.log("📄 app/_layout.tsx created.");

    console.log("\n✅ Project reset complete. Next steps:");
    console.log(
      `1. Run \`npx expo start\` to start a development server.\n2. Edit app/index.tsx to edit the main screen.${
        userInput === "y"
          ? `\n3. Delete the /${exampleDir} directory when you're done referencing it.`
          : ""
      }`
    );
  } catch (error) {
    console.error(`❌ Error during script execution: ${error.message}`);
  }
};

rl.question(
  "Do you want to move existing files to /app-example instead of deleting them? (Y/n): ",
  (answer) => {
    const userInput = answer.trim().toLowerCase() || "y";
    if (userInput === "y" || userInput === "n") {
      moveDirectories(userInput).finally(() => rl.close());
    } else {
      console.log("❌ Invalid input. Please enter 'Y' or 'N'.");
      rl.close();
    }
  }
);

================
File: supabase/.gitignore
================
# Supabase
.branches
.temp

# dotenvx
.env.keys
.env.local
.env.*.local

================
File: supabase/config.toml
================
# For detailed configuration reference documentation, visit:
# https://supabase.com/docs/guides/local-development/cli/config
# A string used to distinguish different Supabase projects on the same host. Defaults to the
# working directory name when running `supabase init`.
project_id = "SnapClone"

[api]
enabled = true
# Port to use for the API URL.
port = 54321
# Schemas to expose in your API. Tables, views and stored procedures in this schema will get API
# endpoints. `public` and `graphql_public` schemas are included by default.
schemas = ["public", "graphql_public"]
# Extra schemas to add to the search_path of every request.
extra_search_path = ["public", "extensions"]
# The maximum number of rows returns from a view, table, or stored procedure. Limits payload size
# for accidental or malicious requests.
max_rows = 1000

[api.tls]
# Enable HTTPS endpoints locally using a self-signed certificate.
enabled = false

[db]
# Port to use for the local database URL.
port = 54322
# Port used by db diff command to initialize the shadow database.
shadow_port = 54320
# The database major version to use. This has to be the same as your remote database's. Run `SHOW
# server_version;` on the remote database to check.
major_version = 17

[db.pooler]
enabled = false
# Port to use for the local connection pooler.
port = 54329
# Specifies when a server connection can be reused by other clients.
# Configure one of the supported pooler modes: `transaction`, `session`.
pool_mode = "transaction"
# How many server connections to allow per user/database pair.
default_pool_size = 20
# Maximum number of client connections allowed.
max_client_conn = 100

# [db.vault]
# secret_key = "env(SECRET_VALUE)"

[db.migrations]
# If disabled, migrations will be skipped during a db push or reset.
enabled = true
# Specifies an ordered list of schema files that describe your database.
# Supports glob patterns relative to supabase directory: "./schemas/*.sql"
schema_paths = []

[db.seed]
# If enabled, seeds the database after migrations during a db reset.
enabled = true
# Specifies an ordered list of seed files to load during db reset.
# Supports glob patterns relative to supabase directory: "./seeds/*.sql"
sql_paths = ["./seed.sql"]

[realtime]
enabled = true
# Bind realtime via either IPv4 or IPv6. (default: IPv4)
# ip_version = "IPv6"
# The maximum length in bytes of HTTP request headers. (default: 4096)
# max_header_length = 4096

[studio]
enabled = true
# Port to use for Supabase Studio.
port = 54323
# External URL of the API server that frontend connects to.
api_url = "http://127.0.0.1"
# OpenAI API Key to use for Supabase AI in the Supabase Studio.
openai_api_key = "env(OPENAI_API_KEY)"

# Email testing server. Emails sent with the local dev setup are not actually sent - rather, they
# are monitored, and you can view the emails that would have been sent from the web interface.
[inbucket]
enabled = true
# Port to use for the email testing server web interface.
port = 54324
# Uncomment to expose additional ports for testing user applications that send emails.
# smtp_port = 54325
# pop3_port = 54326
# admin_email = "admin@email.com"
# sender_name = "Admin"

[storage]
enabled = true
# The maximum file size allowed (e.g. "5MB", "500KB").
file_size_limit = "50MiB"

# Image transformation API is available to Supabase Pro plan.
# [storage.image_transformation]
# enabled = true

# Uncomment to configure local storage buckets
# [storage.buckets.images]
# public = false
# file_size_limit = "50MiB"
# allowed_mime_types = ["image/png", "image/jpeg"]
# objects_path = "./images"

[auth]
enabled = true
# The base URL of your website. Used as an allow-list for redirects and for constructing URLs used
# in emails.
site_url = "http://127.0.0.1:3000"
# A list of *exact* URLs that auth providers are permitted to redirect to post authentication.
additional_redirect_urls = ["https://127.0.0.1:3000"]
# How long tokens are valid for, in seconds. Defaults to 3600 (1 hour), maximum 604,800 (1 week).
jwt_expiry = 3600
# If disabled, the refresh token will never expire.
enable_refresh_token_rotation = true
# Allows refresh tokens to be reused after expiry, up to the specified interval in seconds.
# Requires enable_refresh_token_rotation = true.
refresh_token_reuse_interval = 10
# Allow/disallow new user signups to your project.
enable_signup = true
# Allow/disallow anonymous sign-ins to your project.
enable_anonymous_sign_ins = false
# Allow/disallow testing manual linking of accounts
enable_manual_linking = false
# Passwords shorter than this value will be rejected as weak. Minimum 6, recommended 8 or more.
minimum_password_length = 6
# Passwords that do not meet the following requirements will be rejected as weak. Supported values
# are: `letters_digits`, `lower_upper_letters_digits`, `lower_upper_letters_digits_symbols`
password_requirements = ""

[auth.rate_limit]
# Number of emails that can be sent per hour. Requires auth.email.smtp to be enabled.
email_sent = 2
# Number of SMS messages that can be sent per hour. Requires auth.sms to be enabled.
sms_sent = 30
# Number of anonymous sign-ins that can be made per hour per IP address. Requires enable_anonymous_sign_ins = true.
anonymous_users = 30
# Number of sessions that can be refreshed in a 5 minute interval per IP address.
token_refresh = 150
# Number of sign up and sign-in requests that can be made in a 5 minute interval per IP address (excludes anonymous users).
sign_in_sign_ups = 30
# Number of OTP / Magic link verifications that can be made in a 5 minute interval per IP address.
token_verifications = 30
# Number of Web3 logins that can be made in a 5 minute interval per IP address.
web3 = 30

# Configure one of the supported captcha providers: `hcaptcha`, `turnstile`.
# [auth.captcha]
# enabled = true
# provider = "hcaptcha"
# secret = ""

[auth.email]
# Allow/disallow new user signups via email to your project.
enable_signup = true
# If enabled, a user will be required to confirm any email change on both the old, and new email
# addresses. If disabled, only the new email is required to confirm.
double_confirm_changes = true
# If enabled, users need to confirm their email address before signing in.
enable_confirmations = false
# If enabled, users will need to reauthenticate or have logged in recently to change their password.
secure_password_change = false
# Controls the minimum amount of time that must pass before sending another signup confirmation or password reset email.
max_frequency = "1s"
# Number of characters used in the email OTP.
otp_length = 6
# Number of seconds before the email OTP expires (defaults to 1 hour).
otp_expiry = 3600

# Use a production-ready SMTP server
# [auth.email.smtp]
# enabled = true
# host = "smtp.sendgrid.net"
# port = 587
# user = "apikey"
# pass = "env(SENDGRID_API_KEY)"
# admin_email = "admin@email.com"
# sender_name = "Admin"

# Uncomment to customize email template
# [auth.email.template.invite]
# subject = "You have been invited"
# content_path = "./supabase/templates/invite.html"

[auth.sms]
# Allow/disallow new user signups via SMS to your project.
enable_signup = false
# If enabled, users need to confirm their phone number before signing in.
enable_confirmations = false
# Template for sending OTP to users
template = "Your code is {{ .Code }}"
# Controls the minimum amount of time that must pass before sending another sms otp.
max_frequency = "5s"

# Use pre-defined map of phone number to OTP for testing.
# [auth.sms.test_otp]
# 4152127777 = "123456"

# Configure logged in session timeouts.
# [auth.sessions]
# Force log out after the specified duration.
# timebox = "24h"
# Force log out if the user has been inactive longer than the specified duration.
# inactivity_timeout = "8h"

# This hook runs before a token is issued and allows you to add additional claims based on the authentication method used.
# [auth.hook.custom_access_token]
# enabled = true
# uri = "pg-functions://<database>/<schema>/<hook_name>"

# Configure one of the supported SMS providers: `twilio`, `twilio_verify`, `messagebird`, `textlocal`, `vonage`.
[auth.sms.twilio]
enabled = false
account_sid = ""
message_service_sid = ""
# DO NOT commit your Twilio auth token to git. Use environment variable substitution instead:
auth_token = "env(SUPABASE_AUTH_SMS_TWILIO_AUTH_TOKEN)"

# Multi-factor-authentication is available to Supabase Pro plan.
[auth.mfa]
# Control how many MFA factors can be enrolled at once per user.
max_enrolled_factors = 10

# Control MFA via App Authenticator (TOTP)
[auth.mfa.totp]
enroll_enabled = false
verify_enabled = false

# Configure MFA via Phone Messaging
[auth.mfa.phone]
enroll_enabled = false
verify_enabled = false
otp_length = 6
template = "Your code is {{ .Code }}"
max_frequency = "5s"

# Configure MFA via WebAuthn
# [auth.mfa.web_authn]
# enroll_enabled = true
# verify_enabled = true

# Use an external OAuth provider. The full list of providers are: `apple`, `azure`, `bitbucket`,
# `discord`, `facebook`, `github`, `gitlab`, `google`, `keycloak`, `linkedin_oidc`, `notion`, `twitch`,
# `twitter`, `slack`, `spotify`, `workos`, `zoom`.
[auth.external.apple]
enabled = false
client_id = ""
# DO NOT commit your OAuth provider secret to git. Use environment variable substitution instead:
secret = "env(SUPABASE_AUTH_EXTERNAL_APPLE_SECRET)"
# Overrides the default auth redirectUrl.
redirect_uri = ""
# Overrides the default auth provider URL. Used to support self-hosted gitlab, single-tenant Azure,
# or any other third-party OIDC providers.
url = ""
# If enabled, the nonce check will be skipped. Required for local sign in with Google auth.
skip_nonce_check = false

# Allow Solana wallet holders to sign in to your project via the Sign in with Solana (SIWS, EIP-4361) standard.
# You can configure "web3" rate limit in the [auth.rate_limit] section and set up [auth.captcha] if self-hosting.
[auth.web3.solana]
enabled = false

# Use Firebase Auth as a third-party provider alongside Supabase Auth.
[auth.third_party.firebase]
enabled = false
# project_id = "my-firebase-project"

# Use Auth0 as a third-party provider alongside Supabase Auth.
[auth.third_party.auth0]
enabled = false
# tenant = "my-auth0-tenant"
# tenant_region = "us"

# Use AWS Cognito (Amplify) as a third-party provider alongside Supabase Auth.
[auth.third_party.aws_cognito]
enabled = false
# user_pool_id = "my-user-pool-id"
# user_pool_region = "us-east-1"

# Use Clerk as a third-party provider alongside Supabase Auth.
[auth.third_party.clerk]
enabled = false
# Obtain from https://clerk.com/setup/supabase
# domain = "example.clerk.accounts.dev"

[edge_runtime]
enabled = true
# Configure one of the supported request policies: `oneshot`, `per_worker`.
# Use `oneshot` for hot reload, or `per_worker` for load testing.
policy = "oneshot"
# Port to attach the Chrome inspector for debugging edge functions.
inspector_port = 8083
# The Deno major version to use.
deno_version = 1

# [edge_runtime.secrets]
# secret_key = "env(SECRET_VALUE)"

[analytics]
enabled = true
port = 54327
# Configure one of the supported backends: `postgres`, `bigquery`.
backend = "postgres"

# Experimental features may be deprecated any time
[experimental]
# Configures Postgres storage engine to use OrioleDB (S3)
orioledb_version = ""
# Configures S3 bucket URL, eg. <bucket_name>.s3-<region>.amazonaws.com
s3_host = "env(S3_HOST)"
# Configures S3 bucket region, eg. us-east-1
s3_region = "env(S3_REGION)"
# Configures AWS_ACCESS_KEY_ID for S3 bucket
s3_access_key = "env(S3_ACCESS_KEY)"
# Configures AWS_SECRET_ACCESS_KEY for S3 bucket
s3_secret_key = "env(S3_SECRET_KEY)"

================
File: .env.example
================
EXPO_PUBLIC_SUPABASE_URL=
EXPO_PUBLIC_SUPABASE_ANON_KEY=
SUPABASE_SERVICE_ROLE_KEY=
DATABASE_URL=

================
File: eslint.config.js
================
// https://docs.expo.dev/guides/using-eslint/
const { defineConfig } = require('eslint/config');
const expoConfig = require('eslint-config-expo/flat');

module.exports = defineConfig([
  expoConfig,
  {
    ignores: ['dist/*'],
  },
]);

================
File: README.md
================
# Welcome to your Expo app 👋

This is an [Expo](https://expo.dev) project created with [`create-expo-app`](https://www.npmjs.com/package/create-expo-app).

## Get started

1. Install dependencies

   ```bash
   npm install
   ```

2. Start the app

   ```bash
   npx expo start
   ```

In the output, you'll find options to open the app in a

- [development build](https://docs.expo.dev/develop/development-builds/introduction/)
- [Android emulator](https://docs.expo.dev/workflow/android-studio-emulator/)
- [iOS simulator](https://docs.expo.dev/workflow/ios-simulator/)
- [Expo Go](https://expo.dev/go), a limited sandbox for trying out app development with Expo

You can start developing by editing the files inside the **app** directory. This project uses [file-based routing](https://docs.expo.dev/router/introduction).

## Get a fresh project

When you're ready, run:

```bash
npm run reset-project
```

This command will move the starter code to the **app-example** directory and create a blank **app** directory where you can start developing.

## Learn more

To learn more about developing your project with Expo, look at the following resources:

- [Expo documentation](https://docs.expo.dev/): Learn fundamentals, or go into advanced topics with our [guides](https://docs.expo.dev/guides).
- [Learn Expo tutorial](https://docs.expo.dev/tutorial/introduction/): Follow a step-by-step tutorial where you'll create a project that runs on Android, iOS, and the web.

## Join the community

Join our community of developers creating universal apps.

- [Expo on GitHub](https://github.com/expo/expo): View our open source platform and contribute.
- [Discord community](https://chat.expo.dev): Chat with Expo users and ask questions.

================
File: tsconfig.json
================
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".expo/types/**/*.ts",
    "expo-env.d.ts"
  ]
}

================
File: app/(tabs)/_layout.tsx
================
import { Tabs } from 'expo-router';
import React from 'react';
import { Platform } from 'react-native';

import { HapticTab } from '@/components/HapticTab';
import { IconSymbol } from '@/components/ui/IconSymbol';
import TabBarBackground from '@/components/ui/TabBarBackground';
import { Colors } from '@/constants/Colors';
import { useColorScheme } from '@/hooks/useColorScheme';

export default function TabLayout() {
  const colorScheme = useColorScheme();

  return (
    <Tabs
      screenOptions={{
        tabBarActiveTintColor: Colors[colorScheme ?? 'light'].tint,
        headerShown: false,
        tabBarButton: HapticTab,
        tabBarBackground: TabBarBackground,
        tabBarStyle: Platform.select({
          ios: {
            // Use a transparent background on iOS to show the blur effect
            position: 'absolute',
          },
          default: {},
        }),
      }}>
      <Tabs.Screen
        name="index"
        options={{
          title: 'Home',
          tabBarIcon: ({ color }) => <IconSymbol size={28} name="house.fill" color={color} />,
        }}
      />
      <Tabs.Screen
        name="explore"
        options={{
          title: 'Explore',
          tabBarIcon: ({ color }) => <IconSymbol size={28} name="paperplane.fill" color={color} />,
        }}
      />
      <Tabs.Screen
        name="camera"
        options={{
          title: 'Camera',
          tabBarIcon: ({ color }) => <IconSymbol size={28} name="camera.fill" color={color} />,
        }}
      />
    </Tabs>
  );
}

================
File: app/(tabs)/camera.tsx
================
/**
 * Camera Screen Component
 * 
 * This component provides camera functionality for the SnapClone app.
 * Features:
 * - Camera permissions handling
 * - Photo capture with quality settings
 * - Image preview after capture
 * - Photo upload to Supabase Storage
 * - Themed styling that adapts to light/dark mode
 * - Error handling and loading states
 */

import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';
import { useThemeColor } from '@/hooks/useThemeColor';
import { uploadPhoto } from '@/lib/photoService';
import { CameraView, useCameraPermissions } from 'expo-camera';
import React, { useRef, useState } from 'react';
import { Alert, Image, StyleSheet, Text, TouchableOpacity, View } from 'react-native';

export default function CameraScreen() {
  // Camera reference for accessing camera methods
  const cameraRef = useRef<CameraView>(null);
  
  // State for captured photo URI
  const [capturedPhoto, setCapturedPhoto] = useState<string | null>(null);
  
  // State for capturing process
  const [isCapturing, setIsCapturing] = useState(false);
  
  // State for upload process
  const [isUploading, setIsUploading] = useState(false);
  
  // State for upload success
  const [uploadSuccess, setUploadSuccess] = useState(false);
  
  // Camera permissions hook
  const [permission, requestPermission] = useCameraPermissions();
  
  // Themed colors
  const backgroundColor = useThemeColor({}, 'background');
  const textColor = useThemeColor({}, 'text');
  const tintColor = useThemeColor({}, 'tint');

  console.log('🎥 Camera Screen - Rendering with permission:', permission?.granted);
  console.log('📷 Camera Screen - Captured photo:', capturedPhoto ? 'Photo captured' : 'No photo');
  console.log('⏫ Camera Screen - Upload state:', { isUploading, uploadSuccess });

  /**
   * Handle camera permission request
   */
  const handlePermissionRequest = async () => {
    console.log('🔐 Camera Screen - Requesting camera permission');
    try {
      const result = await requestPermission();
      console.log('✅ Camera Screen - Permission result:', result.granted);
      
      if (!result.granted) {
        Alert.alert(
          'Camera Permission Required',
          'This app needs camera access to take photos. Please enable camera permissions in your device settings.',
          [{ text: 'OK' }]
        );
      }
    } catch (error) {
      console.error('❌ Camera Screen - Permission error:', error);
      Alert.alert('Error', 'Failed to request camera permission');
    }
  };

  /**
   * Capture photo using camera
   */
  const capturePhoto = async () => {
    console.log('📸 Camera Screen - Starting photo capture');
    
    if (!cameraRef.current) {
      console.error('❌ Camera Screen - Camera ref not available');
      Alert.alert('Error', 'Camera not ready');
      return;
    }

    try {
      setIsCapturing(true);
      
      // Take picture with optimized quality settings
      const photo = await cameraRef.current.takePictureAsync({
        quality: 0.6, // Balanced quality and file size
        base64: false, // Don't include base64 to save memory
        skipProcessing: false, // Allow processing for better quality
      });
      
      console.log('✅ Camera Screen - Photo captured:', photo.uri);
      setCapturedPhoto(photo.uri);
      setUploadSuccess(false); // Reset upload success state
      
    } catch (error) {
      console.error('❌ Camera Screen - Capture error:', error);
      Alert.alert('Error', 'Failed to capture photo');
    } finally {
      setIsCapturing(false);
    }
  };

  /**
   * Upload photo to Supabase
   */
  const handleUploadPhoto = async () => {
    if (!capturedPhoto) {
      console.error('❌ Camera Screen - No photo to upload');
      Alert.alert('Error', 'No photo to upload');
      return;
    }

    console.log('⏫ Camera Screen - Starting photo upload');
    setIsUploading(true);

    try {
      const result = await uploadPhoto(capturedPhoto);
      
      if (result.success) {
        console.log('✅ Camera Screen - Photo uploaded successfully!');
        console.log('🌐 Public URL:', result.publicUrl);
        
        setUploadSuccess(true);
        Alert.alert(
          'Success! 🎉',
          'Your photo has been uploaded to Supabase!',
          [
            {
              text: 'Take Another',
              onPress: resetCamera,
            },
            {
              text: 'OK',
              style: 'default',
            },
          ]
        );
      } else {
        console.error('❌ Camera Screen - Upload failed:', result.error);
        Alert.alert(
          'Upload Failed',
          result.error || 'Failed to upload photo. Please try again.',
          [{ text: 'OK' }]
        );
      }
    } catch (error) {
      console.error('❌ Camera Screen - Upload error:', error);
      Alert.alert(
        'Upload Error',
        'An unexpected error occurred while uploading. Please try again.',
        [{ text: 'OK' }]
      );
    } finally {
      setIsUploading(false);
    }
  };

  /**
   * Reset to camera view from preview
   */
  const resetCamera = () => {
    console.log('🔄 Camera Screen - Resetting camera view');
    setCapturedPhoto(null);
    setUploadSuccess(false);
  };

  // Handle permission not granted
  if (!permission) {
    console.log('⏳ Camera Screen - Permission loading');
    return (
      <ThemedView style={styles.container}>
        <ThemedText style={styles.loadingText}>Loading camera...</ThemedText>
      </ThemedView>
    );
  }

  if (!permission.granted) {
    console.log('🚫 Camera Screen - Permission not granted');
    return (
      <ThemedView style={styles.container}>
        <ThemedView style={styles.permissionContainer}>
          <ThemedText style={styles.permissionTitle}>Camera Access Required</ThemedText>
          <ThemedText style={styles.permissionText}>
            SnapClone needs access to your camera to take photos
          </ThemedText>
          <TouchableOpacity
            style={[styles.permissionButton, { backgroundColor: tintColor }]}
            onPress={handlePermissionRequest}
          >
            <Text style={[styles.permissionButtonText, { color: 'white' }]}>
              Grant Camera Permission
            </Text>
          </TouchableOpacity>
        </ThemedView>
      </ThemedView>
    );
  }

  return (
    <View style={[styles.container, { backgroundColor }]}>
      {capturedPhoto ? (
        // Photo preview mode
        <>
          <Image 
            source={{ uri: capturedPhoto }} 
            style={styles.previewImage}
            resizeMode="cover"
          />
          <View style={styles.previewOverlay}>
            <View style={styles.buttonContainer}>
              <TouchableOpacity
                style={[styles.secondaryButton, { borderColor: tintColor }]}
                onPress={resetCamera}
                disabled={isUploading}
              >
                <Text style={[styles.secondaryButtonText, { color: tintColor }]}>
                  Take Another
                </Text>
              </TouchableOpacity>
              
              <TouchableOpacity
                style={[
                  styles.primaryButton,
                  { backgroundColor: uploadSuccess ? '#4CAF50' : tintColor },
                  isUploading && styles.buttonDisabled
                ]}
                onPress={handleUploadPhoto}
                disabled={isUploading || uploadSuccess}
              >
                <Text style={styles.primaryButtonText}>
                  {isUploading 
                    ? 'Uploading...' 
                    : uploadSuccess 
                      ? 'Uploaded! ✅' 
                      : 'Save to Supabase'}
                </Text>
              </TouchableOpacity>
            </View>
            
            {isUploading && (
              <Text style={[styles.statusText, { color: textColor }]}>
                📤 Uploading to Supabase...
              </Text>
            )}
          </View>
        </>
      ) : (
        // Camera mode
        <>
          <CameraView 
            ref={cameraRef} 
            style={styles.camera} 
            facing="back"
          />
          <View style={styles.cameraOverlay}>
            <TouchableOpacity
              style={[
                styles.captureButton,
                { borderColor: tintColor },
                isCapturing && styles.captureButtonDisabled
              ]}
              onPress={capturePhoto}
              disabled={isCapturing}
            >
              <View style={[
                styles.captureButtonInner,
                { backgroundColor: isCapturing ? '#ccc' : 'white' }
              ]} />
            </TouchableOpacity>
            
            {isCapturing && (
              <Text style={[styles.capturingText, { color: textColor }]}>
                Capturing...
              </Text>
            )}
          </View>
        </>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  
  // Loading state
  loadingText: {
    textAlign: 'center',
    marginTop: 100,
    fontSize: 18,
  },
  
  // Permission request
  permissionContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  permissionTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 16,
    textAlign: 'center',
  },
  permissionText: {
    fontSize: 16,
    textAlign: 'center',
    marginBottom: 32,
    lineHeight: 24,
  },
  permissionButton: {
    paddingHorizontal: 32,
    paddingVertical: 16,
    borderRadius: 8,
  },
  permissionButtonText: {
    fontSize: 16,
    fontWeight: '600',
  },
  
  // Camera view
  camera: {
    flex: 1,
  },
  cameraOverlay: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    height: 120,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
  },
  captureButton: {
    width: 80,
    height: 80,
    borderRadius: 40,
    borderWidth: 4,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'transparent',
  },
  captureButtonInner: {
    width: 60,
    height: 60,
    borderRadius: 30,
  },
  captureButtonDisabled: {
    opacity: 0.5,
  },
  capturingText: {
    position: 'absolute',
    bottom: 20,
    fontSize: 16,
    fontWeight: '600',
  },
  
  // Preview mode
  previewImage: {
    flex: 1,
    width: '100%',
  },
  previewOverlay: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    height: 140,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    paddingHorizontal: 20,
  },
  buttonContainer: {
    flexDirection: 'row',
    gap: 16,
    marginBottom: 8,
  },
  primaryButton: {
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 8,
    minWidth: 140,
    alignItems: 'center',
  },
  primaryButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '600',
  },
  secondaryButton: {
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 8,
    borderWidth: 2,
    minWidth: 120,
    alignItems: 'center',
  },
  secondaryButtonText: {
    fontSize: 16,
    fontWeight: '600',
  },
  buttonDisabled: {
    opacity: 0.6,
  },
  statusText: {
    fontSize: 14,
    textAlign: 'center',
    marginTop: 8,
  },
});

================
File: app/(tabs)/index.tsx
================
import { Image } from 'expo-image';
import { Platform, StyleSheet } from 'react-native';

import { HelloWave } from '@/components/HelloWave';
import ParallaxScrollView from '@/components/ParallaxScrollView';
import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';

export default function HomeScreen() {
  return (
    <ParallaxScrollView
      headerBackgroundColor={{ light: '#A1CEDC', dark: '#1D3D47' }}
      headerImage={
        <Image
          source={require('@/assets/images/partial-react-logo.png')}
          style={styles.reactLogo}
        />
      }>
      <ThemedView style={styles.titleContainer}>
        <ThemedText type="title">Hey Georgia!</ThemedText>
        <HelloWave />
      </ThemedView>
      <ThemedView style={styles.stepContainer}>
        <ThemedText type="subtitle">Step 1: Try it</ThemedText>
        <ThemedText>
          Edit <ThemedText type="defaultSemiBold">app/(tabs)/index.tsx</ThemedText> to see changes.
          Press{' '}
          <ThemedText type="defaultSemiBold">
            {Platform.select({
              ios: 'cmd + d',
              android: 'cmd + m',
              web: 'F12',
            })}
          </ThemedText>{' '}
          to open developer tools.
        </ThemedText>
      </ThemedView>
      <ThemedView style={styles.stepContainer}>
        <ThemedText type="subtitle">Step 2: Explore</ThemedText>
        <ThemedText>
          {`Tap the Explore tab to learn more about what's included in this starter app.`}
        </ThemedText>
      </ThemedView>
      <ThemedView style={styles.stepContainer}>
        <ThemedText type="subtitle">Step 3: Get a fresh start</ThemedText>
        <ThemedText>
          {`When you're ready, run `}
          <ThemedText type="defaultSemiBold">npm run reset-project</ThemedText> to get a fresh{' '}
          <ThemedText type="defaultSemiBold">app</ThemedText> directory. This will move the current{' '}
          <ThemedText type="defaultSemiBold">app</ThemedText> to{' '}
          <ThemedText type="defaultSemiBold">app-example</ThemedText>.
        </ThemedText>
      </ThemedView>
    </ParallaxScrollView>
  );
}

const styles = StyleSheet.create({
  titleContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  stepContainer: {
    gap: 8,
    marginBottom: 8,
  },
  reactLogo: {
    height: 178,
    width: 290,
    bottom: 0,
    left: 0,
    position: 'absolute',
  },
});

================
File: app/_layout.tsx
================
import 'react-native-url-polyfill/auto';

import { DarkTheme, DefaultTheme, ThemeProvider } from '@react-navigation/native';
import { useFonts } from 'expo-font';
import { Stack } from 'expo-router';
import { StatusBar } from 'expo-status-bar';
import 'react-native-reanimated';

import { useColorScheme } from '@/hooks/useColorScheme';

export default function RootLayout() {
  const colorScheme = useColorScheme();
  const [loaded] = useFonts({
    SpaceMono: require('../assets/fonts/SpaceMono-Regular.ttf'),
  });

  if (!loaded) {
    // Async font loading only occurs in development.
    return null;
  }

  return (
    <ThemeProvider value={colorScheme === 'dark' ? DarkTheme : DefaultTheme}>
      <Stack>
        <Stack.Screen name="(tabs)" options={{ headerShown: false }} />
        <Stack.Screen name="+not-found" />
      </Stack>
      <StatusBar style="auto" />
    </ThemeProvider>
  );
}

================
File: components/ui/IconSymbol.tsx
================
// Fallback for using MaterialIcons on Android and web.

import MaterialIcons from '@expo/vector-icons/MaterialIcons';
import { SymbolViewProps, SymbolWeight } from 'expo-symbols';
import { ComponentProps } from 'react';
import { OpaqueColorValue, type StyleProp, type TextStyle } from 'react-native';

type IconMapping = Record<SymbolViewProps['name'], ComponentProps<typeof MaterialIcons>['name']>;
type IconSymbolName = keyof typeof MAPPING;

/**
 * Add your SF Symbols to Material Icons mappings here.
 * - see Material Icons in the [Icons Directory](https://icons.expo.fyi).
 * - see SF Symbols in the [SF Symbols](https://developer.apple.com/sf-symbols/) app.
 */
const MAPPING = {
  'house.fill': 'home',
  'paperplane.fill': 'send',
  'chevron.left.forwardslash.chevron.right': 'code',
  'chevron.right': 'chevron-right',
  'camera.fill': 'camera-alt',
} as IconMapping;

/**
 * An icon component that uses native SF Symbols on iOS, and Material Icons on Android and web.
 * This ensures a consistent look across platforms, and optimal resource usage.
 * Icon `name`s are based on SF Symbols and require manual mapping to Material Icons.
 */
export function IconSymbol({
  name,
  size = 24,
  color,
  style,
}: {
  name: IconSymbolName;
  size?: number;
  color: string | OpaqueColorValue;
  style?: StyleProp<TextStyle>;
  weight?: SymbolWeight;
}) {
  return <MaterialIcons color={color} size={size} name={MAPPING[name]} style={style} />;
}

================
File: app.json
================
{
  "expo": {
    "name": "SnapClone",
    "slug": "SnapClone",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/icon.png",
    "scheme": "snapclone",
    "userInterfaceStyle": "automatic",
    "newArchEnabled": true,
    "ios": {
      "supportsTablet": true
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/images/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "edgeToEdgeEnabled": true
    },
    "web": {
      "bundler": "metro",
      "output": "static",
      "favicon": "./assets/images/favicon.png"
    },
    "plugins": [
      "expo-router",
      [
        "expo-splash-screen",
        {
          "image": "./assets/images/splash-icon.png",
          "imageWidth": 200,
          "resizeMode": "contain",
          "backgroundColor": "#ffffff"
        }
      ],
      [
        "expo-camera",
        {
          "cameraPermission": "Allow SnapClone to access your camera to take photos",
          "microphonePermission": "Allow SnapClone to access your microphone to record videos",
          "recordAudioAndroid": true
        }
      ]
    ],
    "experiments": {
      "typedRoutes": true
    }
  }
}

================
File: .gitignore
================
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
.kotlin/
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local
.env
# typescript
*.tsbuildinfo

app-example

# Local configuration - do not commit
mcp.json

SupabaseAdmin.json

================
File: package.json
================
{
  "name": "snapclone",
  "main": "expo-router/entry",
  "version": "1.0.0",
  "scripts": {
    "start": "expo start",
    "reset-project": "node ./scripts/reset-project.js",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web",
    "lint": "expo lint"
  },
  "dependencies": {
    "@expo/server": "^0.6.3",
    "@expo/vector-icons": "^14.1.0",
    "@react-navigation/bottom-tabs": "^7.3.10",
    "@react-navigation/elements": "^2.3.8",
    "@react-navigation/native": "^7.1.6",
    "@supabase/supabase-js": "^2.50.0",
    "base64-arraybuffer": "^1.0.2",
    "expo": "~53.0.12",
    "expo-av": "~15.1.6",
    "expo-blur": "~14.1.5",
    "expo-camera": "~16.1.8",
    "expo-constants": "~17.1.6",
    "expo-file-system": "^18.1.10",
    "expo-font": "~13.3.1",
    "expo-haptics": "~14.1.4",
    "expo-image": "~2.3.0",
    "expo-image-picker": "~16.1.4",
    "expo-linking": "~7.1.5",
    "expo-router": "~5.1.0",
    "expo-splash-screen": "~0.30.9",
    "expo-status-bar": "~2.2.3",
    "expo-symbols": "~0.4.5",
    "expo-system-ui": "~5.0.9",
    "expo-web-browser": "~14.2.0",
    "react": "19.0.0",
    "react-dom": "19.0.0",
    "react-native": "0.79.4",
    "react-native-gesture-handler": "~2.24.0",
    "react-native-reanimated": "~3.17.4",
    "react-native-safe-area-context": "5.4.0",
    "react-native-screens": "~4.11.1",
    "react-native-web": "~0.20.0",
    "react-native-webview": "13.13.5",
    "zustand": "^5.0.5"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@types/react": "~19.0.10",
    "eslint": "^9.25.0",
    "eslint-config-expo": "~9.2.0",
    "react-native-url-polyfill": "^2.0.0",
    "typescript": "~5.8.3"
  },
  "private": true
}




================================================================
End of Codebase
================================================================
